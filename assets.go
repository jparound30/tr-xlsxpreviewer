package main

import (
	"time"

	"github.com/deadcheat/goblet"
)

//go:generate goblet -o assets.go assets

// Assets a generated file system
var Assets = goblet.NewFS(
	map[string][]string{
		"/assets": []string{
			"css", "index.html", "js",
		},
		"/assets/css": []string{
			"index.css",
		},
		"/assets/js": []string{
			"index.js", "pagedown",
		},
		"/assets/js/pagedown": []string{
			"Markdown.Converter.js", "Markdown.Editor.js", "Markdown.Sanitizer.js",
		},
	},
	map[string]*goblet.File{
		"/assets":               goblet.NewFile("/assets", nil, 0x800001ed, time.Unix(1540040946, 1540040946053058014)),
		"/assets/css":           goblet.NewFile("/assets/css", nil, 0x800001ed, time.Unix(1540024253, 1540024253565885549)),
		"/assets/css/index.css": goblet.NewFile("/assets/css/index.css", []byte(_Assetsb7f6143913dc0b734d74e8e842edc3e02f1359d7), 0x1a4, time.Unix(1540024253, 1540024253564832848)),
		"/assets/index.html":    goblet.NewFile("/assets/index.html", []byte(_Assetsf0a1e684333a9c2a21538b70ce7e4d8779474dac), 0x1a4, time.Unix(1540040946, 1540040946052375939)),
		"/assets/js":            goblet.NewFile("/assets/js", nil, 0x800001ed, time.Unix(1540042656, 1540042656831213619)),
		"/assets/js/index.js":   goblet.NewFile("/assets/js/index.js", []byte(_Assetsf0dede7240a0f180620c46629b8a13433c57c458), 0x1a4, time.Unix(1540042656, 1540042656830327689)),
		"/assets/js/pagedown":   goblet.NewFile("/assets/js/pagedown", nil, 0x800001ed, time.Unix(1540034053, 1540034053517214162)),
		"/assets/js/pagedown/Markdown.Converter.js": goblet.NewFile("/assets/js/pagedown/Markdown.Converter.js", []byte(_Assets540a8ed658982d83e3ab9e47a1eb8ea9b5f77dfb), 0x1ed, time.Unix(1540034053, 1540034053515611743)),
		"/assets/js/pagedown/Markdown.Editor.js":    goblet.NewFile("/assets/js/pagedown/Markdown.Editor.js", []byte(_Assetsef03506d38a1579e0c8774e90793a769eaba5a1f), 0x1ed, time.Unix(1540034053, 1540034053516990992)),
		"/assets/js/pagedown/Markdown.Sanitizer.js": goblet.NewFile("/assets/js/pagedown/Markdown.Sanitizer.js", []byte(_Assets7b4451bf44c19997d6e8ee9d3a75cba707236a6b), 0x1ed, time.Unix(1540034053, 1540034053517743112)),
	},
)

// binary data
var (
	_Assetsb7f6143913dc0b734d74e8e842edc3e02f1359d7 = "body {\n    background-color: White;\n}\n\nblockquote {\n    border-left: 2px dotted #888;\n    padding-left: 5px;\n    background: #d0f0ff;\n}\n\ntable, th, td {\n    border-collapse: collapse;\n    border: #999999 1px solid;\n}\n\nth {\n    background: #f5f5f5;\n    font-weight: bold;\n    color: #505050\n}\n\n.tr-markdown > p {\n    white-space: pre-wrap;\n}\n.tr-markdown {\n    margin: 16px\n}\n\n.tr-markdown table th, .tr-markdown table td {\n    padding: 8px;\n    margin: 0;\n    text-align: left;\n    line-height: 1.2;\n    border: 1px solid #d7d7d7;\n    vertical-align: top;\n\n}\n\n#testcase-header {\n    padding-top: 0;\n}\n.testcase-breadcrumbs {\n    padding: 0;\n}\n.testcase-header {\n    padding-top: 0;\n}\n.testcase-title {\n    padding-top: 0;\n    padding-left: 0;\n}\n\n[v-cloak] > * { display:none; }\n"
	_Assetsf0a1e684333a9c2a21538b70ce7e4d8779474dac = "<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Preview</title>\n    <link href='https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons' rel=\"stylesheet\">\n    <link href=\"https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css\" rel=\"stylesheet\">\n    <link href=\"/css/index.css\" rel=\"stylesheet\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\">\n    <link rel=\"stylesheet\" href=\"//cdn.materialdesignicons.com/2.8.94/css/materialdesignicons.min.css\">\n\n    <script src=\"/js/pagedown/Markdown.Converter.js\"></script>\n    <script src=\"/js/pagedown/Markdown.Sanitizer.js\"></script>\n    <script src=\"/js/pagedown/Markdown.Editor.js\"></script>\n\n</head>\n<body>\n<div id=\"app\">\n    <v-app v-cloak>\n        <v-toolbar dense light>\n            <v-toolbar-title>Preview</v-toolbar-title>\n            <v-spacer></v-spacer>\n            <v-toolbar-items>\n                <v-btn flat href=\"/api/downloadCsv\">\n                    <v-icon light>mdi-download</v-icon>CSV download\n                </v-btn>\n            </v-toolbar-items>\n        </v-toolbar>\n        <v-container fluid grid-list-md>\n            <div>\n                <div><a href=\"http://docs.gurock.com/testrail-userguide/userguide-editor\" target=\"_blank\">Official Markdown Reference</a></div>\n                <div><small>Keyboard shortcut:</small> [←]: show previous test case. / [→] show next test case.</div>\n            </div>\n            <v-data-iterator\n                    :items=\"items\"\n                    :rows-per-page-items=\"rowsPerPageItems\"\n                    :pagination.sync=\"pagination\"\n                    content-tag=\"v-layout\"\n                    row\n                    wrap\n                    loading=\"loading\"\n                    ref=\"dataiterator\"\n            >\n                <v-flex\n                        slot=\"item\"\n                        slot-scope=\"props\"\n                        xs12\n                        sm12\n                        md12\n                        lg12\n                >\n                    <v-card>\n                        <v-card-title class=\"testcase-breadcrumbs\">\n                            <v-breadcrumbs divider=\">\">\n                                <v-breadcrumbs-item\n                                        v-for=\"section in props.item.Sections\"\n                                        :key=\"section\"\n                                >\n                                    {{ section }}\n                                </v-breadcrumbs-item>\n                            </v-breadcrumbs>\n                            /&nbsp;&nbsp;<h4>ID: {{ props.item.ID }}</h4>\n                        </v-card-title>\n                        <v-divider></v-divider>\n                        <v-card-text>\n                            <v-container fluid grid-list-md class=\"testcase-header\">\n                                <v-card flat>\n                                    <v-card-title class=\"testcase-title\">\n                                        <div>\n                                            <div class=\"subtitle\">Title</div>\n                                            <span class=\"title\">{{ props.item.Title }}</span>\n                                        </div>\n                                    </v-card-title>\n                                </v-card>\n                                <v-layout row wrap>\n                                    <v-flex\n                                            xs12\n                                            sm6\n                                            md4\n                                            lg3\n                                    >\n                                        <v-card dark>\n                                            <v-card-title>\n                                                <div>\n                                                    <div class=\"body\">Type</div>\n                                                    <span class=\"subtitle\">{{ props.item.Type }}</span>\n                                                </div>\n                                            </v-card-title>\n                                        </v-card>\n                                    </v-flex>\n                                    <v-flex\n                                            xs12\n                                            sm6\n                                            md4\n                                            lg3\n                                    >\n                                        <v-card dark>\n                                            <v-card-title>\n                                                <div>\n                                                    <div class=\"body\">Priority</div>\n                                                    <span class=\"subtitle\">{{ props.item.Priority }}</span>\n                                                </div>\n                                            </v-card-title>\n                                        </v-card>\n                                    </v-flex>\n                                </v-layout>\n                                <v-layout column wrap>\n                                    <v-flex mt-2 mb-2>\n                                        <h3>Preconditions</h3>\n                                        <v-divider></v-divider>\n                                        <div class=\"tr-markdown\"\n                                             v-html=\"convertMarkdownToHtml(props.item.Preconditions)\"></div>\n                                    </v-flex>\n                                    <v-flex mt-2 mb-2>\n                                        <h3>Steps</h3>\n                                        <v-divider></v-divider>\n                                        <div class=\"tr-markdown\" v-html=\"convertMarkdownToHtml(props.item.Steps)\"></div>\n                                    </v-flex>\n                                    <v-flex mt-2 mb-2>\n                                        <h3>ExpectedResult</h3>\n                                        <v-divider></v-divider>\n                                        <div class=\"tr-markdown\"\n                                             v-html=\"convertMarkdownToHtml(props.item.ExpectedResult)\"></div>\n                                    </v-flex>\n                                </v-layout>\n                            </v-container>\n                        </v-card-text>\n                    </v-card>\n                </v-flex>\n            </v-data-iterator>\n        </v-container>\n        <v-snackbar\n                v-model=\"snackbar\"\n                left\n                top\n                :timeout=\"snackbarTimeout\"\n        >\n            {{ snackbarText }}\n            <v-btn\n                    color=\"pink\"\n                    flat\n                    @click=\"snackbar = false\"\n            >\n                Close\n            </v-btn>\n        </v-snackbar>\n    </v-app>\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script src=\"/js/index.js\"></script>\n</body>\n</html>"

	_Assetsf0dede7240a0f180620c46629b8a13433c57c458 = "let app = new Vue({\n  el: '#app',\n  data: {\n    rowsPerPageItems: [\n      1,\n      {\n        text: 'ALL',\n        value: -1\n      }\n    ],\n    pagination: {\n      rowsPerPage: 1\n    },\n    items: [],\n    saneConverter: null,\n    loading: true,\n    snackbar: false,\n    snackbarText: \"\",\n    snackbarTimeout: 1000,\n  },\n\n  created: function () {\n    let self = this;\n\n    // self.saneConverter = Markdown.getSanitizingConverter();\n    self.saneConverter = new Markdown.Converter();\n\n    // テーブルをなんとなくサポートするHook処理を登録\n    self.saneConverter.hooks.chain(\"preBlockGamut\", function (text) {\n\n      return text.replace(/((^\\|\\|.+\\n(^\\|\\|.+\\n)*\\n*)+)/gm,\n        function (wholeMatch, m1) {\n          // console.log(\"wholeMatch:\" + wholeMatch);\n          // console.log(\"m1:\" + m1);\n\n          let splits = m1.split(\"\\n\");\n          let table = \"<table>\";\n          for (let i = 0; i < splits.length; i++) {\n            let line = splits[i];\n            if (/^\\|\\|\\|.*$/g.test(line)) {\n              // ヘッダ行\n              let inners = line.replace(\"|||\", \"\").split(\"|\");\n              let str = \"<tr>\";\n              for (let r in inners) {\n                str += \"<th>\" + inners[r].trim() + \"</th>\";\n              }\n              str += \"</tr>\";\n              table += str;\n            } else if (!/^$/.test(line)) {\n              // ヘッダ行ではない\n              let inners = line.replace(/^(\\|\\|)(.+)/, \"$2\").split(\"|\");\n              let str = \"<tr>\";\n              for (let r in inners) {\n                str += \"<td>\" + inners[r].trim() + \"</td>\";\n              }\n              str += \"</tr>\";\n              table += str;\n            }\n          }\n          table += \"</table>\\n\";\n\n          return table;\n        }\n      );\n    });\n\n    axios.get('/api/testcases')\n      .then(function (response) {\n        self.items = response.data;\n        self.loading = false;\n      })\n      .catch(reason => {\n        console.error(reason);\n        self.loading = false;\n        self.snackbar = true;\n        self.snackbarText = \"Error: Input file maybe contain some invalid content\";\n        self.snackbarTimeout = 10 * 1000;\n      });\n\n    // WS\n    var conn = new WebSocket(\"ws://localhost:10080/ws\");\n    conn.onclose = function (evt) {\n      console.log('Connection closed');\n    };\n    conn.onmessage = function (evt) {\n      let data = JSON.parse(evt.data);\n      if (data.err) {\n        console.error(data.err);\n        self.snackbarText = \"Error: \" + data.err;\n        self.snackbarTimeout = 10 * 1000;\n      } else {\n        self.items = data.testCases;\n        self.snackbarText = \"Updated.\";\n        self.snackbarTimeout = 1000;\n      }\n      self.snackbar = true;\n    };\n\n    // key\n    document.addEventListener(\"keydown\", function (e) {\n      switch (e.key) {\n        case \"ArrowLeft\":\n          self.prevPage();\n          break;\n        case \"ArrowRight\":\n          self.nextPage();\n          break;\n      }\n    });\n\n  },\n\n  methods: {\n    convertMarkdownToHtml: function (md) {\n      return this.saneConverter.makeHtml(md);\n    },\n    nextPage: function () {\n      if (this.pagination.rowsPerPage < 0 ||\n        this.pagination.page * this.pagination.rowsPerPage >= this.$refs[\"dataiterator\"].itemsLength ||\n        this.$refs[\"dataiterator\"].pageStop < 0) {\n        return;\n      }\n      const cp = this.$refs[\"dataiterator\"].computedPagination.page;\n      this.$refs[\"dataiterator\"].updatePagination({page: cp + 1,})\n    },\n    prevPage: function () {\n      const cp = this.$refs[\"dataiterator\"].computedPagination.page;\n      if (cp === 1) {\n        return;\n      }\n      this.$refs[\"dataiterator\"].updatePagination({page: cp - 1,})\n    }\n  },\n});\n"

	_Assets540a8ed658982d83e3ab9e47a1eb8ea9b5f77dfb = "\"use strict\";\nvar Markdown;\n\nif (typeof exports === \"object\" && typeof require === \"function\") // we're in a CommonJS (e.g. Node.js) module\n    Markdown = exports;\nelse\n    Markdown = {};\n\n// The following text is included for historical reasons, but should\n// be taken with a pinch of salt; it's not all true anymore.\n\n//\n// Wherever possible, Showdown is a straight, line-by-line port\n// of the Perl version of Markdown.\n//\n// This is not a normal parser design; it's basically just a\n// series of string substitutions.  It's hard to read and\n// maintain this way,  but keeping Showdown close to the original\n// design makes it easier to port new features.\n//\n// More importantly, Showdown behaves like markdown.pl in most\n// edge cases.  So web applications can do client-side preview\n// in Javascript, and then build identical HTML on the server.\n//\n// This port needs the new RegExp functionality of ECMA 262,\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\n// should do fine.  Even with the new regular expression features,\n// We do a lot of work to emulate Perl's regex functionality.\n// The tricky changes in this file mostly have the \"attacklab:\"\n// label.  Major or self-explanatory changes don't.\n//\n// Smart diff tools like Araxis Merge will be able to match up\n// this file with markdown.pl in a useful way.  A little tweaking\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\n// and line endings.\n//\n\n\n//\n// Usage:\n//\n//   var text = \"Markdown *rocks*.\";\n//\n//   var converter = new Markdown.Converter();\n//   var html = converter.makeHtml(text);\n//\n//   alert(html);\n//\n// Note: move the sample code to the bottom of this\n// file before uncommenting it.\n//\n\n(function () {\n\n    function identity(x) { return x; }\n    function returnFalse(x) { return false; }\n\n    function HookCollection() { }\n\n    HookCollection.prototype = {\n\n        chain: function (hookname, func) {\n            var original = this[hookname];\n            if (!original)\n                throw new Error(\"unknown hook \" + hookname);\n\n            if (original === identity)\n                this[hookname] = func;\n            else\n                this[hookname] = function (text) {\n                    var args = Array.prototype.slice.call(arguments, 0);\n                    args[0] = original.apply(null, args);\n                    return func.apply(null, args);\n                };\n        },\n        set: function (hookname, func) {\n            if (!this[hookname])\n                throw new Error(\"unknown hook \" + hookname);\n            this[hookname] = func;\n        },\n        addNoop: function (hookname) {\n            this[hookname] = identity;\n        },\n        addFalse: function (hookname) {\n            this[hookname] = returnFalse;\n        }\n    };\n\n    Markdown.HookCollection = HookCollection;\n\n    // g_urls and g_titles allow arbitrary user-entered strings as keys. This\n    // caused an exception (and hence stopped the rendering) when the user entered\n    // e.g. [push] or [__proto__]. Adding a prefix to the actual key prevents this\n    // (since no builtin property starts with \"s_\"). See\n    // http://meta.stackexchange.com/questions/64655/strange-wmd-bug\n    // (granted, switching from Array() to Object() alone would have left only __proto__\n    // to be a problem)\n    function SaveHash() { }\n    SaveHash.prototype = {\n        set: function (key, value) {\n            this[\"s_\" + key] = value;\n        },\n        get: function (key) {\n            return this[\"s_\" + key];\n        }\n    };\n\n    Markdown.Converter = function (OPTIONS) {\n        var pluginHooks = this.hooks = new HookCollection();\n        \n        // given a URL that was encountered by itself (without markup), should return the link text that's to be given to this link\n        pluginHooks.addNoop(\"plainLinkText\");\n        \n        // called with the orignal text as given to makeHtml. The result of this plugin hook is the actual markdown source that will be cooked\n        pluginHooks.addNoop(\"preConversion\");\n        \n        // called with the text once all normalizations have been completed (tabs to spaces, line endings, etc.), but before any conversions have\n        pluginHooks.addNoop(\"postNormalization\");\n        \n        // Called with the text before / after creating block elements like code blocks and lists. Note that this is called recursively\n        // with inner content, e.g. it's called with the full text, and then only with the content of a blockquote. The inner\n        // call will receive outdented text.\n        pluginHooks.addNoop(\"preBlockGamut\");\n        pluginHooks.addNoop(\"postBlockGamut\");\n        \n        // called with the text of a single block element before / after the span-level conversions (bold, code spans, etc.) have been made\n        pluginHooks.addNoop(\"preSpanGamut\");\n        pluginHooks.addNoop(\"postSpanGamut\");\n        \n        // called with the final cooked HTML code. The result of this plugin hook is the actual output of makeHtml\n        pluginHooks.addNoop(\"postConversion\");\n\n        //\n        // Private state of the converter instance:\n        //\n\n        // Global hashes, used by various utility routines\n        var g_urls;\n        var g_titles;\n        var g_html_blocks;\n\n        // Used to track when we're inside an ordered or unordered list\n        // (see _ProcessListItems() for details):\n        var g_list_level;\n        \n        OPTIONS = OPTIONS || {};\n        var asciify = identity, deasciify = identity;\n        if (OPTIONS.nonAsciiLetters) {\n\n            /* In JavaScript regular expressions, \\w only denotes [a-zA-Z0-9_].\n             * That's why there's inconsistent handling e.g. with intra-word bolding\n             * of Japanese words. That's why we do the following if OPTIONS.nonAsciiLetters\n             * is true:\n             *\n             * Before doing bold and italics, we find every instance\n             * of a unicode word character in the Markdown source that is not\n             * matched by \\w, and the letter \"Q\". We take the character's code point\n             * and encode it in base 51, using the \"digits\"\n             *\n             *     A, B, ..., P, R, ..., Y, Z, a, b, ..., y, z\n             *\n             * delimiting it with \"Q\" on both sides. For example, the source\n             *\n             * > In Chinese, the smurfs are called 藍精靈, meaning \"blue spirits\".\n             *\n             * turns into\n             *\n             * > In Chinese, the smurfs are called QNIhQQMOIQQOuUQ, meaning \"blue spirits\".\n             *\n             * Since everything that is a letter in Unicode is now a letter (or\n             * several letters) in ASCII, \\w and \\b should always do the right thing.\n             *\n             * After the bold/italic conversion, we decode again; since \"Q\" was encoded\n             * alongside all non-ascii characters (as \"QBfQ\"), and the conversion\n             * will not generate \"Q\", the only instances of that letter should be our\n             * encoded characters. And since the conversion will not break words, the\n             * \"Q...Q\" should all still be in one piece.\n             *\n             * We're using \"Q\" as the delimiter because it's probably one of the\n             * rarest characters, and also because I can't think of any special behavior\n             * that would ever be triggered by this letter (to use a silly example, if we\n             * delimited with \"H\" on the left and \"P\" on the right, then \"Ψ\" would be\n             * encoded as \"HTTP\", which may cause special behavior). The latter would not\n             * actually be a huge issue for bold/italic, but may be if we later use it\n             * in other places as well.\n             * */            \n            (function () {\n                var lettersThatJavaScriptDoesNotKnowAndQ = /[Q\\u00aa\\u00b5\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0621-\\u064a\\u0660-\\u0669\\u066e-\\u066f\\u0671-\\u06d3\\u06d5\\u06e5-\\u06e6\\u06ee-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07c0-\\u07ea\\u07f4-\\u07f5\\u07fa\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0966-\\u096f\\u0971-\\u0972\\u097b-\\u097f\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc-\\u09dd\\u09df-\\u09e1\\u09e6-\\u09f1\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a6f\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0-\\u0ae1\\u0ae6-\\u0aef\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c-\\u0b5d\\u0b5f-\\u0b61\\u0b66-\\u0b6f\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0be6-\\u0bef\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58-\\u0c59\\u0c60-\\u0c61\\u0c66-\\u0c6f\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0-\\u0ce1\\u0ce6-\\u0cef\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d28\\u0d2a-\\u0d39\\u0d3d\\u0d60-\\u0d61\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32-\\u0e33\\u0e40-\\u0e46\\u0e50-\\u0e59\\u0e81-\\u0e82\\u0e84\\u0e87-\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa-\\u0eab\\u0ead-\\u0eb0\\u0eb2-\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ed0-\\u0ed9\\u0edc-\\u0edd\\u0f00\\u0f20-\\u0f29\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8b\\u1000-\\u102a\\u103f-\\u1049\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065-\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u1090-\\u1099\\u10a0-\\u10c5\\u10d0-\\u10fa\\u10fc\\u1100-\\u1159\\u115f-\\u11a2\\u11a8-\\u11f9\\u1200-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u1676\\u1681-\\u169a\\u16a0-\\u16ea\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u17e0-\\u17e9\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u1900-\\u191c\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19a9\\u19c1-\\u19c7\\u19d0-\\u19d9\\u1a00-\\u1a16\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b50-\\u1b59\\u1b83-\\u1ba0\\u1bae-\\u1bb9\\u1c00-\\u1c23\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u203f-\\u2040\\u2054\\u2071\\u207f\\u2090-\\u2094\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2183-\\u2184\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2c6f\\u2c71-\\u2c7d\\u2c80-\\u2ce4\\u2d00-\\u2d25\\u2d30-\\u2d65\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3006\\u3031-\\u3035\\u303b-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31b7\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fc3\\ua000-\\ua48c\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua65f\\ua662-\\ua66e\\ua67f-\\ua697\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78c\\ua7fb-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8d0-\\ua8d9\\ua900-\\ua925\\ua930-\\ua946\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa50-\\uaa59\\uac00-\\ud7a3\\uf900-\\ufa2d\\ufa30-\\ufa6a\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe33-\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]/g;\n                var cp_Q = \"Q\".charCodeAt(0);\n                var cp_A = \"A\".charCodeAt(0);\n                var cp_Z = \"Z\".charCodeAt(0);\n                var dist_Za = \"a\".charCodeAt(0) - cp_Z - 1;\n                \n                asciify = function(text) {\n                    return text.replace(lettersThatJavaScriptDoesNotKnowAndQ, function (m) {\n                        var c = m.charCodeAt(0);\n                        var s = \"\";\n                        var v;\n                        while (c > 0) {\n                            v = (c % 51) + cp_A;\n                            if (v >= cp_Q)\n                                v++;\n                            if (v > cp_Z)\n                                v += dist_Za;\n                            s = String.fromCharCode(v) + s;\n                            c = c / 51 | 0;\n                        }\n                        return \"Q\" + s + \"Q\";\n                    })\n                };\n                \n                deasciify = function(text) {\n                    return text.replace(/Q([A-PR-Za-z]{1,3})Q/g, function (m, s) {\n                        var c = 0;\n                        var v;\n                        for (var i = 0; i < s.length; i++) {\n                            v = s.charCodeAt(i);\n                            if (v > cp_Z)\n                                v -= dist_Za;\n                            if (v > cp_Q)\n                                v--;\n                            v -= cp_A;\n                            c = (c * 51) + v;\n                        }\n                        return String.fromCharCode(c);\n                    })\n                }                \n            })();\n        }\n        \n        var _DoItalicsAndBold = OPTIONS.asteriskIntraWordEmphasis ? _DoItalicsAndBold_AllowIntrawordWithAsterisk : _DoItalicsAndBoldStrict;\n\n        this.makeHtml = function (text) {\n\n            //\n            // Main function. The order in which other subs are called here is\n            // essential. Link and image substitutions need to happen before\n            // _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\n            // and <img> tags get encoded.\n            //\n\n            // This will only happen if makeHtml on the same converter instance is called from a plugin hook.\n            // Don't do that.\n            if (g_urls)\n                throw new Error(\"Recursive call to converter.makeHtml\");\n        \n            // Create the private state objects.\n            g_urls = new SaveHash();\n            g_titles = new SaveHash();\n            g_html_blocks = [];\n            g_list_level = 0;\n\n            text = pluginHooks.preConversion(text);\n\n            // attacklab: Replace ~ with ~T\n            // This lets us use tilde as an escape char to avoid md5 hashes\n            // The choice of character is arbitray; anything that isn't\n            // magic in Markdown will work.\n            text = text.replace(/~/g, \"~T\");\n\n            // attacklab: Replace $ with ~D\n            // RegExp interprets $ as a special character\n            // when it's in a replacement string\n            text = text.replace(/\\$/g, \"~D\");\n\n            // Standardize line endings\n            text = text.replace(/\\r\\n/g, \"\\n\"); // DOS to Unix\n            text = text.replace(/\\r/g, \"\\n\"); // Mac to Unix\n\n            // Make sure text begins and ends with a couple of newlines:\n            text = \"\\n\\n\" + text + \"\\n\\n\";\n\n            // Convert all tabs to spaces.\n            text = _Detab(text);\n\n            // Strip any lines consisting only of spaces and tabs.\n            // This makes subsequent regexen easier to write, because we can\n            // match consecutive blank lines with /\\n+/ instead of something\n            // contorted like /[ \\t]*\\n+/ .\n            text = text.replace(/^[ \\t]+$/mg, \"\");\n            \n            text = pluginHooks.postNormalization(text);\n\n            // Turn block-level HTML blocks into hash entries\n            text = _HashHTMLBlocks(text);\n\n            // Strip link definitions, store in hashes.\n            text = _StripLinkDefinitions(text);\n\n            text = _RunBlockGamut(text);\n\n            text = _UnescapeSpecialChars(text);\n\n            // attacklab: Restore dollar signs\n            text = text.replace(/~D/g, \"$$\");\n\n            // attacklab: Restore tildes\n            text = text.replace(/~T/g, \"~\");\n\n            text = pluginHooks.postConversion(text);\n\n            g_html_blocks = g_titles = g_urls = null;\n\n            return text;\n        };\n\n        function _StripLinkDefinitions(text) {\n            //\n            // Strips link definitions from text, stores the URLs and titles in\n            // hash references.\n            //\n\n            // Link defs are in the form: ^[id]: url \"optional title\"\n\n            /*\n            text = text.replace(/\n                ^[ ]{0,3}\\[([^\\[\\]]+)\\]:  // id = $1  attacklab: g_tab_width - 1\n                [ \\t]*\n                \\n?                 // maybe *one* newline\n                [ \\t]*\n                <?(\\S+?)>?          // url = $2\n                (?=\\s|$)            // lookahead for whitespace instead of the lookbehind removed below\n                [ \\t]*\n                \\n?                 // maybe one newline\n                [ \\t]*\n                (                   // (potential) title = $3\n                    (\\n*)           // any lines skipped = $4 attacklab: lookbehind removed\n                    [ \\t]+\n                    [\"(]\n                    (.+?)           // title = $5\n                    [\")]\n                    [ \\t]*\n                )?                  // title is optional\n                (\\n+)             // subsequent newlines = $6, capturing because they must be put back if the potential title isn't an actual title\n            /gm, function(){...});\n            */\n\n            text = text.replace(/^[ ]{0,3}\\[([^\\[\\]]+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?(?=\\s|$)[ \\t]*\\n?[ \\t]*((\\n*)[\"(](.+?)[\")][ \\t]*)?(\\n+)/gm,\n                function (wholeMatch, m1, m2, m3, m4, m5, m6) {\n                    m1 = m1.toLowerCase();\n                    g_urls.set(m1, _EncodeAmpsAndAngles(m2));  // Link IDs are case-insensitive\n                    if (m4) {\n                        // Oops, found blank lines, so it's not a title.\n                        // Put back the parenthetical statement we stole.\n                        return m3 + m6;\n                    } else if (m5) {\n                        g_titles.set(m1, m5.replace(/\"/g, \"&quot;\"));\n                    }\n\n                    // Completely remove the definition from the text\n                    return \"\";\n                }\n            );\n\n            return text;\n        }\n\n        function _HashHTMLBlocks(text) {\n\n            // Hashify HTML blocks:\n            // We only want to do this for block-level HTML tags, such as headers,\n            // lists, and tables. That's because we still want to wrap <p>s around\n            // \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\n            // phrase emphasis, and spans. The list of tags we're looking for is\n            // hard-coded:\n            var block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del\"\n            var block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math\"\n\n            // First, look for nested blocks, e.g.:\n            //   <div>\n            //     <div>\n            //     tags for inner block must be indented.\n            //     </div>\n            //   </div>\n            //\n            // The outermost tags must start at the left margin for this to match, and\n            // the inner nested divs must be indented.\n            // We need to do this before the next, more liberal match, because the next\n            // match will start at the first `<div>` and stop at the first `</div>`.\n\n            // attacklab: This regex can be expensive when it fails.\n\n            /*\n            text = text.replace(/\n                (                       // save in $1\n                    ^                   // start of line  (with /m)\n                    <($block_tags_a)    // start tag = $2\n                    \\b                  // word break\n                                        // attacklab: hack around khtml/pcre bug...\n                    [^\\r]*?\\n           // any number of lines, minimally matching\n                    </\\2>               // the matching end tag\n                    [ \\t]*              // trailing spaces/tabs\n                    (?=\\n+)             // followed by a newline\n                )                       // attacklab: there are sentinel newlines at end of document\n            /gm,function(){...}};\n            */\n            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm, hashMatch);\n\n            //\n            // Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\n            //\n\n            /*\n            text = text.replace(/\n                (                       // save in $1\n                    ^                   // start of line  (with /m)\n                    <($block_tags_b)    // start tag = $2\n                    \\b                  // word break\n                                        // attacklab: hack around khtml/pcre bug...\n                    [^\\r]*?             // any number of lines, minimally matching\n                    .*</\\2>             // the matching end tag\n                    [ \\t]*              // trailing spaces/tabs\n                    (?=\\n+)             // followed by a newline\n                )                       // attacklab: there are sentinel newlines at end of document\n            /gm,function(){...}};\n            */\n            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm, hashMatch);\n\n            // Special case just for <hr />. It was easier to make a special case than\n            // to make the other regex more complicated.  \n\n            /*\n            text = text.replace(/\n                \\n                  // Starting after a blank line\n                [ ]{0,3}\n                (                   // save in $1\n                    (<(hr)          // start tag = $2\n                        \\b          // word break\n                        ([^<>])*?\n                    \\/?>)           // the matching end tag\n                    [ \\t]*\n                    (?=\\n{2,})      // followed by a blank line\n                )\n            /g,hashMatch);\n            */\n            text = text.replace(/\\n[ ]{0,3}((<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g, hashMatch);\n\n            // Special case for standalone HTML comments:\n\n            /*\n            text = text.replace(/\n                \\n\\n                                            // Starting after a blank line\n                [ ]{0,3}                                        // attacklab: g_tab_width - 1\n                (                                               // save in $1\n                    <!\n                    (--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)   // see http://www.w3.org/TR/html-markup/syntax.html#comments and http://meta.stackexchange.com/q/95256\n                    >\n                    [ \\t]*\n                    (?=\\n{2,})                                  // followed by a blank line\n                )\n            /g,hashMatch);\n            */\n            text = text.replace(/\\n\\n[ ]{0,3}(<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>[ \\t]*(?=\\n{2,}))/g, hashMatch);\n\n            // PHP and ASP-style processor instructions (<?...?> and <%...%>)\n\n            /*\n            text = text.replace(/\n                (?:\n                    \\n\\n            // Starting after a blank line\n                )\n                (                   // save in $1\n                    [ ]{0,3}        // attacklab: g_tab_width - 1\n                    (?:\n                        <([?%])     // $2\n                        [^\\r]*?\n                        \\2>\n                    )\n                    [ \\t]*\n                    (?=\\n{2,})      // followed by a blank line\n                )\n            /g,hashMatch);\n            */\n            text = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g, hashMatch);\n\n            return text;\n        }\n\n        function hashBlock(text) {\n            text = text.replace(/(^\\n+|\\n+$)/g, \"\");\n            // Replace the element text with a marker (\"~KxK\" where x is its key)\n            return \"\\n\\n~K\" + (g_html_blocks.push(text) - 1) + \"K\\n\\n\";\n        }\n\n        function hashMatch(wholeMatch, m1) {\n            return hashBlock(m1);\n        }\n        \n        var blockGamutHookCallback = function (t) { return _RunBlockGamut(t); }\n\n        function _RunBlockGamut(text, doNotUnhash, doNotCreateParagraphs) {\n            //\n            // These are all the transformations that form block-level\n            // tags like paragraphs, headers, and list items.\n            //\n            \n            text = pluginHooks.preBlockGamut(text, blockGamutHookCallback);\n            \n            text = _DoHeaders(text);\n\n            // Do Horizontal Rules:\n            var replacement = \"<hr />\\n\";\n            text = text.replace(/^[ ]{0,2}( ?\\*){3,}[ \\t]*$/gm, replacement);\n            text = text.replace(/^[ ]{0,2}( ?-){3,}[ \\t]*$/gm, replacement);\n            text = text.replace(/^[ ]{0,2}( ?_){3,}[ \\t]*$/gm, replacement);\n\n            text = _DoLists(text);\n            text = _DoCodeBlocks(text);\n            text = _DoBlockQuotes(text);\n            \n            text = pluginHooks.postBlockGamut(text, blockGamutHookCallback);\n\n            // We already ran _HashHTMLBlocks() before, in Markdown(), but that\n            // was to escape raw HTML in the original Markdown source. This time,\n            // we're escaping the markup we've just created, so that we don't wrap\n            // <p> tags around block-level tags.\n            text = _HashHTMLBlocks(text);\n            \n            text = _FormParagraphs(text, doNotUnhash, doNotCreateParagraphs);\n\n            return text;\n        }\n\n        function _RunSpanGamut(text) {\n            //\n            // These are all the transformations that occur *within* block-level\n            // tags like paragraphs, headers, and list items.\n            //\n\n            text = pluginHooks.preSpanGamut(text);\n            \n            text = _DoCodeSpans(text);\n            text = _EscapeSpecialCharsWithinTagAttributes(text);\n            text = _EncodeBackslashEscapes(text);\n\n            // Process anchor and image tags. Images must come first,\n            // because ![foo][f] looks like an anchor.\n            text = _DoImages(text);\n            text = _DoAnchors(text);\n\n            // Make links out of things like `<http://example.com/>`\n            // Must come after _DoAnchors(), because you can use < and >\n            // delimiters in inline links like [this](<url>).\n            text = _DoAutoLinks(text);\n            \n            text = text.replace(/~P/g, \"://\"); // put in place to prevent autolinking; reset now\n            \n            text = _EncodeAmpsAndAngles(text);\n            text = _DoItalicsAndBold(text);\n\n            // Do hard breaks:\n            text = text.replace(/  +\\n/g, \" <br>\\n\");\n            \n            text = pluginHooks.postSpanGamut(text);\n\n            return text;\n        }\n\n        function _EscapeSpecialCharsWithinTagAttributes(text) {\n            //\n            // Within tags -- meaning between < and > -- encode [\\ ` * _] so they\n            // don't conflict with their use in Markdown for code, italics and strong.\n            //\n\n            // Build a regex to find HTML tags and comments.  See Friedl's \n            // \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\n\n            // SE: changed the comment part of the regex\n\n            var regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>)/gi;\n\n            text = text.replace(regex, function (wholeMatch) {\n                var tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g, \"$1`\");\n                tag = escapeCharacters(tag, wholeMatch.charAt(1) == \"!\" ? \"\\\\`*_/\" : \"\\\\`*_\"); // also escape slashes in comments to prevent autolinking there -- http://meta.stackexchange.com/questions/95987\n                return tag;\n            });\n\n            return text;\n        }\n\n        function _DoAnchors(text) {\n            \n            if (text.indexOf(\"[\") === -1)\n                return text;\n            \n            //\n            // Turn Markdown link shortcuts into XHTML <a> tags.\n            //\n            //\n            // First, handle reference-style links: [link text] [id]\n            //\n\n            /*\n            text = text.replace(/\n                (                           // wrap whole match in $1\n                    \\[\n                    (\n                        (?:\n                            \\[[^\\]]*\\]      // allow brackets nested one level\n                            |\n                            [^\\[]           // or anything else\n                        )*\n                    )\n                    \\]\n\n                    [ ]?                    // one optional space\n                    (?:\\n[ ]*)?             // one optional newline followed by spaces\n\n                    \\[\n                    (.*?)                   // id = $3\n                    \\]\n                )\n                ()()()()                    // pad remaining backreferences\n            /g, writeAnchorTag);\n            */\n            text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, writeAnchorTag);\n\n            //\n            // Next, inline-style links: [link text](url \"optional title\")\n            //\n\n            /*\n            text = text.replace(/\n                (                           // wrap whole match in $1\n                    \\[\n                    (\n                        (?:\n                            \\[[^\\]]*\\]      // allow brackets nested one level\n                            |\n                            [^\\[\\]]         // or anything else\n                        )*\n                    )\n                    \\]\n                    \\(                      // literal paren\n                    [ \\t]*\n                    ()                      // no id, so leave $3 empty\n                    <?(                     // href = $4\n                        (?:\n                            \\([^)]*\\)       // allow one level of (correctly nested) parens (think MSDN)\n                            |\n                            [^()\\s]\n                        )*?\n                    )>?                \n                    [ \\t]*\n                    (                       // $5\n                        (['\"])              // quote char = $6\n                        (.*?)               // Title = $7\n                        \\6                  // matching quote\n                        [ \\t]*              // ignore any spaces/tabs between closing quote and )\n                    )?                      // title is optional\n                    \\)\n                )\n            /g, writeAnchorTag);\n            */\n\n            text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?((?:\\([^)]*\\)|[^()\\s])*?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g, writeAnchorTag);\n\n            //\n            // Last, handle reference-style shortcuts: [link text]\n            // These must come last in case you've also got [link test][1]\n            // or [link test](/foo)\n            //\n\n            /*\n            text = text.replace(/\n                (                   // wrap whole match in $1\n                    \\[\n                    ([^\\[\\]]+)      // link text = $2; can't contain '[' or ']'\n                    \\]\n                )\n                ()()()()()          // pad rest of backreferences\n            /g, writeAnchorTag);\n            */\n            text = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\n\n            return text;\n        }\n\n        function writeAnchorTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {\n            if (m7 == undefined) m7 = \"\";\n            var whole_match = m1;\n            var link_text = m2.replace(/:\\/\\//g, \"~P\"); // to prevent auto-linking within the link. will be converted back after the auto-linker runs\n            var link_id = m3.toLowerCase();\n            var url = m4;\n            var title = m7;\n\n            if (url == \"\") {\n                if (link_id == \"\") {\n                    // lower-case and turn embedded newlines into spaces\n                    link_id = link_text.toLowerCase().replace(/ ?\\n/g, \" \");\n                }\n                url = \"#\" + link_id;\n\n                if (g_urls.get(link_id) != undefined) {\n                    url = g_urls.get(link_id);\n                    if (g_titles.get(link_id) != undefined) {\n                        title = g_titles.get(link_id);\n                    }\n                }\n                else {\n                    if (whole_match.search(/\\(\\s*\\)$/m) > -1) {\n                        // Special case for explicit empty url\n                        url = \"\";\n                    } else {\n                        return whole_match;\n                    }\n                }\n            }\n            url = attributeSafeUrl(url);\n\n            var result = \"<a href=\\\"\" + url + \"\\\"\";\n\n            if (title != \"\") {\n                title = attributeEncode(title);\n                title = escapeCharacters(title, \"*_\");\n                result += \" title=\\\"\" + title + \"\\\"\";\n            }\n\n            result += \">\" + link_text + \"</a>\";\n\n            return result;\n        }\n\n        function _DoImages(text) {\n            \n            if (text.indexOf(\"![\") === -1)\n                return text;\n            \n            //\n            // Turn Markdown image shortcuts into <img> tags.\n            //\n\n            //\n            // First, handle reference-style labeled images: ![alt text][id]\n            //\n\n            /*\n            text = text.replace(/\n                (                   // wrap whole match in $1\n                    !\\[\n                    (.*?)           // alt text = $2\n                    \\]\n\n                    [ ]?            // one optional space\n                    (?:\\n[ ]*)?     // one optional newline followed by spaces\n\n                    \\[\n                    (.*?)           // id = $3\n                    \\]\n                )\n                ()()()()            // pad rest of backreferences\n            /g, writeImageTag);\n            */\n            text = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, writeImageTag);\n\n            //\n            // Next, handle inline images:  ![alt text](url \"optional title\")\n            // Don't forget: encode * and _\n\n            /*\n            text = text.replace(/\n                (                   // wrap whole match in $1\n                    !\\[\n                    (.*?)           // alt text = $2\n                    \\]\n                    \\s?             // One optional whitespace character\n                    \\(              // literal paren\n                    [ \\t]*\n                    ()              // no id, so leave $3 empty\n                    <?(\\S+?)>?      // src url = $4\n                    [ \\t]*\n                    (               // $5\n                        (['\"])      // quote char = $6\n                        (.*?)       // title = $7\n                        \\6          // matching quote\n                        [ \\t]*\n                    )?              // title is optional\n                    \\)\n                )\n            /g, writeImageTag);\n            */\n            text = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g, writeImageTag);\n\n            return text;\n        }\n        \n        function attributeEncode(text) {\n            // unconditionally replace angle brackets here -- what ends up in an attribute (e.g. alt or title)\n            // never makes sense to have verbatim HTML in it (and the sanitizer would totally break it)\n            return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n        }\n\n        function writeImageTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {\n            var whole_match = m1;\n            var alt_text = m2;\n            var link_id = m3.toLowerCase();\n            var url = m4;\n            var title = m7;\n\n            if (!title) title = \"\";\n\n            if (url == \"\") {\n                if (link_id == \"\") {\n                    // lower-case and turn embedded newlines into spaces\n                    link_id = alt_text.toLowerCase().replace(/ ?\\n/g, \" \");\n                }\n                url = \"#\" + link_id;\n\n                if (g_urls.get(link_id) != undefined) {\n                    url = g_urls.get(link_id);\n                    if (g_titles.get(link_id) != undefined) {\n                        title = g_titles.get(link_id);\n                    }\n                }\n                else {\n                    return whole_match;\n                }\n            }\n            \n            alt_text = escapeCharacters(attributeEncode(alt_text), \"*_[]()\");\n            url = escapeCharacters(url, \"*_\");\n            var result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\n\n            // attacklab: Markdown.pl adds empty title attributes to images.\n            // Replicate this bug.\n\n            //if (title != \"\") {\n            title = attributeEncode(title);\n            title = escapeCharacters(title, \"*_\");\n            result += \" title=\\\"\" + title + \"\\\"\";\n            //}\n\n            result += \" />\";\n\n            return result;\n        }\n\n        function _DoHeaders(text) {\n\n            // Setext-style headers:\n            //  Header 1\n            //  ========\n            //  \n            //  Header 2\n            //  --------\n            //\n            text = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n                function (wholeMatch, m1) { return \"<h1>\" + _RunSpanGamut(m1) + \"</h1>\\n\\n\"; }\n            );\n\n            text = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\n                function (matchFound, m1) { return \"<h2>\" + _RunSpanGamut(m1) + \"</h2>\\n\\n\"; }\n            );\n\n            // atx-style headers:\n            //  # Header 1\n            //  ## Header 2\n            //  ## Header 2 with closing hashes ##\n            //  ...\n            //  ###### Header 6\n            //\n\n            /*\n            text = text.replace(/\n                ^(\\#{1,6})      // $1 = string of #'s\n                [ \\t]*\n                (.+?)           // $2 = Header text\n                [ \\t]*\n                \\#*             // optional closing #'s (not counted)\n                \\n+\n            /gm, function() {...});\n            */\n\n            text = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\n                function (wholeMatch, m1, m2) {\n                    var h_level = m1.length;\n                    return \"<h\" + h_level + \">\" + _RunSpanGamut(m2) + \"</h\" + h_level + \">\\n\\n\";\n                }\n            );\n\n            return text;\n        }\n\n        function _DoLists(text, isInsideParagraphlessListItem) {\n            //\n            // Form HTML ordered (numbered) and unordered (bulleted) lists.\n            //\n\n            // attacklab: add sentinel to hack around khtml/safari bug:\n            // http://bugs.webkit.org/show_bug.cgi?id=11231\n            text += \"~0\";\n\n            // Re-usable pattern to match any entirel ul or ol list:\n\n            /*\n            var whole_list = /\n                (                                   // $1 = whole list\n                    (                               // $2\n                        [ ]{0,3}                    // attacklab: g_tab_width - 1\n                        ([*+-]|\\d+[.])              // $3 = first list item marker\n                        [ \\t]+\n                    )\n                    [^\\r]+?\n                    (                               // $4\n                        ~0                          // sentinel for workaround; should be $\n                        |\n                        \\n{2,}\n                        (?=\\S)\n                        (?!                         // Negative lookahead for another list item marker\n                            [ \\t]*\n                            (?:[*+-]|\\d+[.])[ \\t]+\n                        )\n                    )\n                )\n            /g\n            */\n            var whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\n            if (g_list_level) {\n                text = text.replace(whole_list, function (wholeMatch, m1, m2) {\n                    var list = m1;\n                    var list_type = (m2.search(/[*+-]/g) > -1) ? \"ul\" : \"ol\";\n                    var first_number;\n                    if (list_type === \"ol\")\n                        first_number = parseInt(m2, 10)\n\n                    var result = _ProcessListItems(list, list_type, isInsideParagraphlessListItem);\n\n                    // Trim any trailing whitespace, to put the closing `</$list_type>`\n                    // up on the preceding line, to get it past the current stupid\n                    // HTML block parser. This is a hack to work around the terrible\n                    // hack that is the HTML block parser.\n                    result = result.replace(/\\s+$/, \"\");\n                    var opening = \"<\" + list_type;\n                    if (first_number && first_number !== 1)\n                        opening += \" start=\\\"\" + first_number + \"\\\"\";\n                    result = opening + \">\" + result + \"</\" + list_type + \">\\n\";\n                    return result;\n                });\n            } else {\n                whole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\n                text = text.replace(whole_list, function (wholeMatch, m1, m2, m3) {\n                    var runup = m1;\n                    var list = m2;\n\n                    var list_type = (m3.search(/[*+-]/g) > -1) ? \"ul\" : \"ol\";\n\n                    var first_number;\n                    if (list_type === \"ol\")\n                        first_number = parseInt(m3, 10)\n\n                    var result = _ProcessListItems(list, list_type);\n                    var opening = \"<\" + list_type;\n                    if (first_number && first_number !== 1)\n                        opening += \" start=\\\"\" + first_number + \"\\\"\";\n\n                    result = runup + opening + \">\\n\" + result + \"</\" + list_type + \">\\n\";\n                    return result;\n                });\n            }\n\n            // attacklab: strip sentinel\n            text = text.replace(/~0/, \"\");\n\n            return text;\n        }\n\n        var _listItemMarkers = { ol: \"\\\\d+[.]\", ul: \"[*+-]\" };\n\n        function _ProcessListItems(list_str, list_type, isInsideParagraphlessListItem) {\n            //\n            //  Process the contents of a single ordered or unordered list, splitting it\n            //  into individual list items.\n            //\n            //  list_type is either \"ul\" or \"ol\".\n\n            // The $g_list_level global keeps track of when we're inside a list.\n            // Each time we enter a list, we increment it; when we leave a list,\n            // we decrement. If it's zero, we're not in a list anymore.\n            //\n            // We do this because when we're not inside a list, we want to treat\n            // something like this:\n            //\n            //    I recommend upgrading to version\n            //    8. Oops, now this line is treated\n            //    as a sub-list.\n            //\n            // As a single paragraph, despite the fact that the second line starts\n            // with a digit-period-space sequence.\n            //\n            // Whereas when we're inside a list (or sub-list), that line will be\n            // treated as the start of a sub-list. What a kludge, huh? This is\n            // an aspect of Markdown's syntax that's hard to parse perfectly\n            // without resorting to mind-reading. Perhaps the solution is to\n            // change the syntax rules such that sub-lists must start with a\n            // starting cardinal number; e.g. \"1.\" or \"a.\".\n\n            g_list_level++;\n\n            // trim trailing blank lines:\n            list_str = list_str.replace(/\\n{2,}$/, \"\\n\");\n\n            // attacklab: add sentinel to emulate \\z\n            list_str += \"~0\";\n\n            // In the original attacklab showdown, list_type was not given to this function, and anything\n            // that matched /[*+-]|\\d+[.]/ would just create the next <li>, causing this mismatch:\n            //\n            //  Markdown          rendered by WMD        rendered by MarkdownSharp\n            //  ------------------------------------------------------------------\n            //  1. first          1. first               1. first\n            //  2. second         2. second              2. second\n            //  - third           3. third                   * third\n            //\n            // We changed this to behave identical to MarkdownSharp. This is the constructed RegEx,\n            // with {MARKER} being one of \\d+[.] or [*+-], depending on list_type:\n        \n            /*\n            list_str = list_str.replace(/\n                (^[ \\t]*)                       // leading whitespace = $1\n                ({MARKER}) [ \\t]+               // list marker = $2\n                ([^\\r]+?                        // list item text   = $3\n                    (\\n+)\n                )\n                (?=\n                    (~0 | \\2 ({MARKER}) [ \\t]+)\n                )\n            /gm, function(){...});\n            */\n\n            var marker = _listItemMarkers[list_type];\n            var re = new RegExp(\"(^[ \\\\t]*)(\" + marker + \")[ \\\\t]+([^\\\\r]+?(\\\\n+))(?=(~0|\\\\1(\" + marker + \")[ \\\\t]+))\", \"gm\");\n            var last_item_had_a_double_newline = false;\n            list_str = list_str.replace(re,\n                function (wholeMatch, m1, m2, m3) {\n                    var item = m3;\n                    var leading_space = m1;\n                    var ends_with_double_newline = /\\n\\n$/.test(item);\n                    var contains_double_newline = ends_with_double_newline || item.search(/\\n{2,}/) > -1;\n                    \n                    var loose = contains_double_newline || last_item_had_a_double_newline;\n                    item = _RunBlockGamut(_Outdent(item), /* doNotUnhash = */true, /* doNotCreateParagraphs = */ !loose);\n                    \n                    last_item_had_a_double_newline = ends_with_double_newline;\n                    return \"<li>\" + item + \"</li>\\n\";\n                }\n            );\n\n            // attacklab: strip sentinel\n            list_str = list_str.replace(/~0/g, \"\");\n\n            g_list_level--;\n            return list_str;\n        }\n\n        function _DoCodeBlocks(text) {\n            //\n            //  Process Markdown `<pre><code>` blocks.\n            //  \n\n            /*\n            text = text.replace(/\n                (?:\\n\\n|^)\n                (                               // $1 = the code block -- one or more lines, starting with a space/tab\n                    (?:\n                        (?:[ ]{4}|\\t)           // Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\n                        .*\\n+\n                    )+\n                )\n                (\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))    // attacklab: g_tab_width\n            /g ,function(){...});\n            */\n\n            // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n            text += \"~0\";\n\n            text = text.replace(/(?:\\n\\n|^\\n?)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\n                function (wholeMatch, m1, m2) {\n                    var codeblock = m1;\n                    var nextChar = m2;\n\n                    codeblock = _EncodeCode(_Outdent(codeblock));\n                    codeblock = _Detab(codeblock);\n                    codeblock = codeblock.replace(/^\\n+/g, \"\"); // trim leading newlines\n                    codeblock = codeblock.replace(/\\n+$/g, \"\"); // trim trailing whitespace\n\n                    codeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\n\n                    return \"\\n\\n\" + codeblock + \"\\n\\n\" + nextChar;\n                }\n            );\n\n            // attacklab: strip sentinel\n            text = text.replace(/~0/, \"\");\n\n            return text;\n        }\n\n        function _DoCodeSpans(text) {\n            //\n            // * Backtick quotes are used for <code></code> spans.\n            // \n            // * You can use multiple backticks as the delimiters if you want to\n            //   include literal backticks in the code span. So, this input:\n            //     \n            //      Just type ``foo `bar` baz`` at the prompt.\n            //     \n            //   Will translate to:\n            //     \n            //      <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n            //     \n            //   There's no arbitrary limit to the number of backticks you\n            //   can use as delimters. If you need three consecutive backticks\n            //   in your code, use four for delimiters, etc.\n            //\n            // * You can use spaces to get literal backticks at the edges:\n            //     \n            //      ... type `` `bar` `` ...\n            //     \n            //   Turns to:\n            //     \n            //      ... type <code>`bar`</code> ...\n            //\n\n            /*\n            text = text.replace(/\n                (^|[^\\\\`])      // Character before opening ` can't be a backslash or backtick\n                (`+)            // $2 = Opening run of `\n                (?!`)           // and no more backticks -- match the full run\n                (               // $3 = The code block\n                    [^\\r]*?\n                    [^`]        // attacklab: work around lack of lookbehind\n                )\n                \\2              // Matching closer\n                (?!`)\n            /gm, function(){...});\n            */\n\n            text = text.replace(/(^|[^\\\\`])(`+)(?!`)([^\\r]*?[^`])\\2(?!`)/gm,\n                function (wholeMatch, m1, m2, m3, m4) {\n                    var c = m3;\n                    c = c.replace(/^([ \\t]*)/g, \"\"); // leading whitespace\n                    c = c.replace(/[ \\t]*$/g, \"\"); // trailing whitespace\n                    c = _EncodeCode(c);\n                    c = c.replace(/:\\/\\//g, \"~P\"); // to prevent auto-linking. Not necessary in code *blocks*, but in code spans. Will be converted back after the auto-linker runs.\n                    return m1 + \"<code>\" + c + \"</code>\";\n                }\n            );\n\n            return text;\n        }\n\n        function _EncodeCode(text) {\n            //\n            // Encode/escape certain characters inside Markdown code runs.\n            // The point is that in code, these characters are literals,\n            // and lose their special Markdown meanings.\n            //\n            // Encode all ampersands; HTML entities are not\n            // entities within a Markdown code span.\n            text = text.replace(/&/g, \"&amp;\");\n\n            // Do the angle bracket song and dance:\n            text = text.replace(/</g, \"&lt;\");\n            text = text.replace(/>/g, \"&gt;\");\n\n            // Now, escape characters that are magic in Markdown:\n            text = escapeCharacters(text, \"\\*_{}[]\\\\\", false);\n\n            // jj the line above breaks this:\n            //---\n\n            //* Item\n\n            //   1. Subitem\n\n            //            special char: *\n            //---\n\n            return text;\n        }\n\n        function _DoItalicsAndBoldStrict(text) {\n\n            if (text.indexOf(\"*\") === -1 && text.indexOf(\"_\") === - 1)\n                return text;\n            \n            text = asciify(text);\n        \n            // <strong> must go first:\n            \n            // (^|[\\W_])           Start with a non-letter or beginning of string. Store in \\1.\n            // (?:(?!\\1)|(?=^))    Either the next character is *not* the same as the previous,\n            //                     or we started at the end of the string (in which case the previous\n            //                     group had zero width, so we're still there). Because the next\n            //                     character is the marker, this means that if there are e.g. multiple\n            //                     underscores in a row, we can only match the left-most ones (which\n            //                     prevents foo___bar__ from getting bolded)\n            // (\\*|_)              The marker character itself, asterisk or underscore. Store in \\2.\n            // \\2                  The marker again, since bold needs two.\n            // (?=\\S)              The first bolded character cannot be a space.\n            // ([^\\r]*?\\S)         The actual bolded string. At least one character, and it cannot *end*\n            //                     with a space either. Note that like in many other places, [^\\r] is\n            //                     just a workaround for JS' lack of single-line regexes; it's equivalent\n            //                     to a . in an /s regex, because the string cannot contain any \\r (they\n            //                     are removed in the normalizing step).\n            // \\2\\2                The marker character, twice -- end of bold.\n            // (?!\\2)              Not followed by another marker character (ensuring that we match the\n            //                     rightmost two in a longer row)...\n            // (?=[\\W_]|$)         ...but by any other non-word character or the end of string.\n            text = text.replace(/(^|[\\W_])(?:(?!\\1)|(?=^))(\\*|_)\\2(?=\\S)([^\\r]*?\\S)\\2\\2(?!\\2)(?=[\\W_]|$)/g,\n            \"$1<strong>$3</strong>\");\n\n            // This is almost identical to the <strong> regex, except 1) there's obviously just one marker\n            // character, and 2) the italicized string cannot contain the marker character.\n            text = text.replace(/(^|[\\W_])(?:(?!\\1)|(?=^))(\\*|_)(?=\\S)((?:(?!\\2)[^\\r])*?\\S)\\2(?!\\2)(?=[\\W_]|$)/g,\n            \"$1<em>$3</em>\");\n\n            return deasciify(text);\n        }\n\n        function _DoItalicsAndBold_AllowIntrawordWithAsterisk(text) {\n            \n            if (text.indexOf(\"*\") === -1 && text.indexOf(\"_\") === - 1)\n                return text;\n            \n            text = asciify(text);\n        \n            // <strong> must go first:\n            // (?=[^\\r][*_]|[*_])               Optimization only, to find potentially relevant text portions faster. Minimally slower in Chrome, but much faster in IE.\n            // (                                Store in \\1. This is the last character before the delimiter\n            //     ^                            Either we're at the start of the string (i.e. there is no last character)...\n            //     |                            ... or we allow one of the following:\n            //     (?=                          (lookahead; we're not capturing this, just listing legal possibilities)\n            //         \\W__                     If the delimiter is __, then this last character must be non-word non-underscore (extra-word emphasis only)\n            //         |\n            //         (?!\\*)[\\W_]\\*\\*          If the delimiter is **, then this last character can be non-word non-asterisk (extra-word emphasis)...\n            //         |\n            //         \\w\\*\\*\\w                 ...or it can be word/underscore, but only if the first bolded character is such a character as well (intra-word emphasis)\n            //     )\n            //     [^\\r]                        actually capture the character (can't use `.` since it could be \\n)\n            // )\n            // (\\*\\*|__)                        Store in \\2: the actual delimiter\n            // (?!\\2)                           not followed by the delimiter again (at most one more asterisk/underscore is allowed)\n            // (?=\\S)                           the first bolded character can't be a space\n            // (                                Store in \\3: the bolded string\n            //                                  \n            //     (?:|                         Look at all bolded characters except for the last one. Either that's empty, meaning only a single character was bolded...\n            //       [^\\r]*?                    ... otherwise take arbitrary characters, minimally matching; that's all bolded characters except for the last *two*\n            //       (?!\\2)                       the last two characters cannot be the delimiter itself (because that would mean four underscores/asterisks in a row)\n            //       [^\\r]                        capture the next-to-last bolded character\n            //     )\n            //     (?=                          lookahead at the very last bolded char and what comes after\n            //         \\S_                      for underscore-bolding, it can be any non-space\n            //         |\n            //         \\w                       for asterisk-bolding (otherwise the previous alternative would've matched, since \\w implies \\S), either the last char is word/underscore...\n            //         |\n            //         \\S\\*\\*(?:[\\W_]|$)        ... or it's any other non-space, but in that case the character *after* the delimiter may not be a word character\n            //     )\n            //     .                            actually capture the last character (can use `.` this time because the lookahead ensures \\S in all cases)\n            // )\n            // (?=                              lookahead; list the legal possibilities for the closing delimiter and its following character\n            //     __(?:\\W|$)                   for underscore-bolding, the following character (if any) must be non-word non-underscore\n            //     |\n            //     \\*\\*(?:[^*]|$)               for asterisk-bolding, any non-asterisk is allowed (note we already ensured above that it's not a word character if the last bolded character wasn't one)\n            // )\n            // \\2                               actually capture the closing delimiter (and make sure that it matches the opening one)\n          \n            text = text.replace(/(?=[^\\r][*_]|[*_])(^|(?=\\W__|(?!\\*)[\\W_]\\*\\*|\\w\\*\\*\\w)[^\\r])(\\*\\*|__)(?!\\2)(?=\\S)((?:|[^\\r]*?(?!\\2)[^\\r])(?=\\S_|\\w|\\S\\*\\*(?:[\\W_]|$)).)(?=__(?:\\W|$)|\\*\\*(?:[^*]|$))\\2/g,\n            \"$1<strong>$3</strong>\");\n\n            // now <em>:\n            // (?=[^\\r][*_]|[*_])               Optimization, see above.\n            // (                                Store in \\1. This is the last character before the delimiter\n            //     ^                            Either we're at the start of the string (i.e. there is no last character)...\n            //     |                            ... or we allow one of the following:\n            //     (?=                          (lookahead; we're not capturing this, just listing legal possibilities)\n            //         \\W_                      If the delimiter is _, then this last character must be non-word non-underscore (extra-word emphasis only)\n            //         |\n            //         (?!\\*)                   otherwise, we list two possibilities for * as the delimiter; in either case, the last characters cannot be an asterisk itself\n            //         (?:\n            //             [\\W_]\\*              this last character can be non-word (extra-word emphasis)...\n            //             |\n            //             \\D\\*(?=\\w)\\D         ...or it can be word (otherwise the first alternative would've matched), but only if\n            //                                      a) the first italicized character is such a character as well (intra-word emphasis), and\n            //                                      b) neither character on either side of the asterisk is a digit            \n            //         )\n            //     )\n            //     [^\\r]                        actually capture the character (can't use `.` since it could be \\n)\n            // )\n            // (\\*|_)                           Store in \\2: the actual delimiter\n            // (?!\\2\\2\\2)                       not followed by more than two more instances of the delimiter\n            // (?=\\S)                           the first italicized character can't be a space\n            // (                                Store in \\3: the italicized string\n            //     (?:(?!\\2)[^\\r])*?            arbitrary characters except for the delimiter itself, minimally matching\n            //     (?=                          lookahead at the very last italicized char and what comes after\n            //         [^\\s_]_                  for underscore-italicizing, it can be any non-space non-underscore\n            //         |\n            //         (?=\\w)\\D\\*\\D             for asterisk-italicizing, either the last char is word/underscore *and* neither character on either side of the asterisk is a digit...\n            //         |\n            //         [^\\s*]\\*(?:[\\W_]|$)      ... or that last char is any other non-space non-asterisk, but then the character after the delimiter (if any) must be non-word\n            //     )\n            //     .                            actually capture the last character (can use `.` this time because the lookahead ensures \\S in all cases)\n            // )\n            // (?=                              lookahead; list the legal possibilities for the closing delimiter and its following character\n            //     _(?:\\W|$)                    for underscore-italicizing, the following character (if any) must be non-word non-underscore\n            //     |\n            //     \\*(?:[^*]|$)                 for asterisk-italicizing, any non-asterisk is allowed; all other restrictions have already been ensured in the previous lookahead\n            // )\n            // \\2                               actually capture the closing delimiter (and make sure that it matches the opening one)\n\n            text = text.replace(/(?=[^\\r][*_]|[*_])(^|(?=\\W_|(?!\\*)(?:[\\W_]\\*|\\D\\*(?=\\w)\\D))[^\\r])(\\*|_)(?!\\2\\2\\2)(?=\\S)((?:(?!\\2)[^\\r])*?(?=[^\\s_]_|(?=\\w)\\D\\*\\D|[^\\s*]\\*(?:[\\W_]|$)).)(?=_(?:\\W|$)|\\*(?:[^*]|$))\\2/g,\n            \"$1<em>$3</em>\");\n            \n            return deasciify(text);\n        }        \n\n        \n        function _DoBlockQuotes(text) {\n\n            /*\n            text = text.replace(/\n                (                           // Wrap whole match in $1\n                    (\n                        ^[ \\t]*>[ \\t]?      // '>' at the start of a line\n                        .+\\n                // rest of the first line\n                        (.+\\n)*             // subsequent consecutive lines\n                        \\n*                 // blanks\n                    )+\n                )\n            /gm, function(){...});\n            */\n\n            text = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\n                function (wholeMatch, m1) {\n                    var bq = m1;\n\n                    // attacklab: hack around Konqueror 3.5.4 bug:\n                    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n                    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, \"~0\"); // trim one level of quoting\n\n                    // attacklab: clean up hack\n                    bq = bq.replace(/~0/g, \"\");\n\n                    bq = bq.replace(/^[ \\t]+$/gm, \"\");     // trim whitespace-only lines\n                    bq = _RunBlockGamut(bq);             // recurse\n\n                    bq = bq.replace(/(^|\\n)/g, \"$1  \");\n                    // These leading spaces screw with <pre> content, so we need to fix that:\n                    bq = bq.replace(\n                            /(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\n                        function (wholeMatch, m1) {\n                            var pre = m1;\n                            // attacklab: hack around Konqueror 3.5.4 bug:\n                            pre = pre.replace(/^  /mg, \"~0\");\n                            pre = pre.replace(/~0/g, \"\");\n                            return pre;\n                        });\n\n                    return hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\n                }\n            );\n            return text;\n        }\n\n        function _FormParagraphs(text, doNotUnhash, doNotCreateParagraphs) {\n            //\n            //  Params:\n            //    $text - string to process with html <p> tags\n            //\n\n            // Strip leading and trailing lines:\n            text = text.replace(/^\\n+/g, \"\");\n            text = text.replace(/\\n+$/g, \"\");\n\n            var grafs = text.split(/\\n{2,}/g);\n            var grafsOut = [];\n            \n            var markerRe = /~K(\\d+)K/;\n\n            //\n            // Wrap <p> tags.\n            //\n            var end = grafs.length;\n            for (var i = 0; i < end; i++) {\n                var str = grafs[i];\n\n                // if this is an HTML marker, copy it\n                if (markerRe.test(str)) {\n                    grafsOut.push(str);\n                }\n                else if (/\\S/.test(str)) {\n                    str = _RunSpanGamut(str);\n                    str = str.replace(/^([ \\t]*)/g, doNotCreateParagraphs ? \"\" : \"<p>\");\n                    if (!doNotCreateParagraphs)\n                        str += \"</p>\"\n                    grafsOut.push(str);\n                }\n\n            }\n            //\n            // Unhashify HTML blocks\n            //\n            if (!doNotUnhash) {\n                end = grafsOut.length;\n                for (var i = 0; i < end; i++) {\n                    var foundAny = true;\n                    while (foundAny) { // we may need several runs, since the data may be nested\n                        foundAny = false;\n                        grafsOut[i] = grafsOut[i].replace(/~K(\\d+)K/g, function (wholeMatch, id) {\n                            foundAny = true;\n                            return g_html_blocks[id];\n                        });\n                    }\n                }\n            }\n            return grafsOut.join(\"\\n\\n\");\n        }\n\n        function _EncodeAmpsAndAngles(text) {\n            // Smart processing for ampersands and angle brackets that need to be encoded.\n\n            // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n            //   http://bumppo.net/projects/amputator/\n            text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, \"&amp;\");\n\n            // Encode naked <'s\n            text = text.replace(/<(?![a-z\\/?!]|~D)/gi, \"&lt;\");\n\n            return text;\n        }\n\n        function _EncodeBackslashEscapes(text) {\n            //\n            //   Parameter:  String.\n            //   Returns:    The string, with after processing the following backslash\n            //               escape sequences.\n            //\n\n            // attacklab: The polite way to do this is with the new\n            // escapeCharacters() function:\n            //\n            //     text = escapeCharacters(text,\"\\\\\",true);\n            //     text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n            //\n            // ...but we're sidestepping its use of the (slow) RegExp constructor\n            // as an optimization for Firefox.  This function gets called a LOT.\n\n            text = text.replace(/\\\\(\\\\)/g, escapeCharacters_callback);\n            text = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g, escapeCharacters_callback);\n            return text;\n        }\n\n        var charInsideUrl = \"[-A-Z0-9+&@#/%?=~_|[\\\\]()!:,.;]\",\n            charEndingUrl = \"[-A-Z0-9+&@#/%=~_|[\\\\])]\",\n            autoLinkRegex = new RegExp(\"(=\\\"|<)?\\\\b(https?|ftp)(://\" + charInsideUrl + \"*\" + charEndingUrl + \")(?=$|\\\\W)\", \"gi\"),\n            endCharRegex = new RegExp(charEndingUrl, \"i\");\n\n        function handleTrailingParens(wholeMatch, lookbehind, protocol, link) {\n            if (lookbehind)\n                return wholeMatch;\n            if (link.charAt(link.length - 1) !== \")\")\n                return \"<\" + protocol + link + \">\";\n            var parens = link.match(/[()]/g);\n            var level = 0;\n            for (var i = 0; i < parens.length; i++) {\n                if (parens[i] === \"(\") {\n                    if (level <= 0)\n                        level = 1;\n                    else\n                        level++;\n                }\n                else {\n                    level--;\n                }\n            }\n            var tail = \"\";\n            if (level < 0) {\n                var re = new RegExp(\"\\\\){1,\" + (-level) + \"}$\");\n                link = link.replace(re, function (trailingParens) {\n                    tail = trailingParens;\n                    return \"\";\n                });\n            }\n            if (tail) {\n                var lastChar = link.charAt(link.length - 1);\n                if (!endCharRegex.test(lastChar)) {\n                    tail = lastChar + tail;\n                    link = link.substr(0, link.length - 1);\n                }\n            }\n            return \"<\" + protocol + link + \">\" + tail;\n        }\n        \n        function _DoAutoLinks(text) {\n\n            // note that at this point, all other URL in the text are already hyperlinked as <a href=\"\"></a>\n            // *except* for the <http://www.foo.com> case\n\n            // automatically add < and > around unadorned raw hyperlinks\n            // must be preceded by a non-word character (and not by =\" or <) and followed by non-word/EOF character\n            // simulating the lookbehind in a consuming way is okay here, since a URL can neither and with a \" nor\n            // with a <, so there is no risk of overlapping matches.\n            text = asciify(text)\n            text = text.replace(autoLinkRegex, handleTrailingParens);\n            text = deasciify(text)\n            //  autolink anything like <http://example.com>\n            \n\n            var replacer = function (wholematch, m1) {\n                var url = attributeSafeUrl(m1);\n                \n                return \"<a href=\\\"\" + url + \"\\\">\" + pluginHooks.plainLinkText(m1) + \"</a>\";\n            };\n            text = text.replace(/<((https?|ftp):[^'\">\\s]+)>/gi, replacer);\n\n            // Email addresses: <address@domain.foo>\n            /*\n            text = text.replace(/\n                <\n                (?:mailto:)?\n                (\n                    [-.\\w]+\n                    \\@\n                    [-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\n                )\n                >\n            /gi, _DoAutoLinks_callback());\n            */\n\n            /* disabling email autolinking, since we don't do that on the server, either\n            text = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n                function(wholeMatch,m1) {\n                    return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\n                }\n            );\n            */\n            return text;\n        }\n\n        function _UnescapeSpecialChars(text) {\n            //\n            // Swap back in all the special characters we've hidden.\n            //\n            text = text.replace(/~E(\\d+)E/g,\n                function (wholeMatch, m1) {\n                    var charCodeToReplace = parseInt(m1);\n                    return String.fromCharCode(charCodeToReplace);\n                }\n            );\n            return text;\n        }\n\n        function _Outdent(text) {\n            //\n            // Remove one level of line-leading tabs or spaces\n            //\n\n            // attacklab: hack around Konqueror 3.5.4 bug:\n            // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n            text = text.replace(/^(\\t|[ ]{1,4})/gm, \"~0\"); // attacklab: g_tab_width\n\n            // attacklab: clean up hack\n            text = text.replace(/~0/g, \"\")\n\n            return text;\n        }\n\n        function _Detab(text) {\n            if (!/\\t/.test(text))\n                return text;\n\n            var spaces = [\"    \", \"   \", \"  \", \" \"],\n            skew = 0,\n            v;\n\n            return text.replace(/[\\n\\t]/g, function (match, offset) {\n                if (match === \"\\n\") {\n                    skew = offset + 1;\n                    return match;\n                }\n                v = (offset - skew) % 4;\n                skew = offset + 1;\n                return spaces[v];\n            });\n        }\n\n        //\n        //  attacklab: Utility functions\n        //\n\n        function attributeSafeUrl(url) {\n            url = attributeEncode(url);\n            url = escapeCharacters(url, \"*_:()[]\")\n            return url;\n        }\n\n        function escapeCharacters(text, charsToEscape, afterBackslash) {\n            // First we have to escape the escape characters so that\n            // we can build a character class out of them\n            var regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g, \"\\\\$1\") + \"])\";\n\n            if (afterBackslash) {\n                regexString = \"\\\\\\\\\" + regexString;\n            }\n\n            var regex = new RegExp(regexString, \"g\");\n            text = text.replace(regex, escapeCharacters_callback);\n\n            return text;\n        }\n\n\n        function escapeCharacters_callback(wholeMatch, m1) {\n            var charCodeToEscape = m1.charCodeAt(0);\n            return \"~E\" + charCodeToEscape + \"E\";\n        }\n\n    }; // end of the Markdown.Converter constructor\n\n})();"
	_Assetsef03506d38a1579e0c8774e90793a769eaba5a1f = "\ufeff// needs Markdown.Converter.js at the moment\n\n(function () {\n\n    var util = {},\n        position = {},\n        ui = {},\n        doc = window.document,\n        re = window.RegExp,\n        nav = window.navigator,\n        SETTINGS = { lineLength: 72 },\n\n    // Used to work around some browser bugs where we can't use feature testing.\n        uaSniffed = {\n            isIE: /msie/.test(nav.userAgent.toLowerCase()),\n            isIE_5or6: /msie 6/.test(nav.userAgent.toLowerCase()) || /msie 5/.test(nav.userAgent.toLowerCase()),\n            isOpera: /opera/.test(nav.userAgent.toLowerCase())\n        };\n\n    var defaultsStrings = {\n        bold: \"Strong <strong> Ctrl+B\",\n        boldexample: \"strong text\",\n\n        italic: \"Emphasis <em> Ctrl+I\",\n        italicexample: \"emphasized text\",\n\n        link: \"Hyperlink <a> Ctrl+L\",\n        linkdescription: \"enter link description here\",\n        linkdialog: \"<p><b>Insert Hyperlink</b></p><p>http://example.com/ \\\"optional title\\\"</p>\",\n\n        quote: \"Blockquote <blockquote> Ctrl+Q\",\n        quoteexample: \"Blockquote\",\n\n        code: \"Code Sample <pre><code> Ctrl+K\",\n        codeexample: \"enter code here\",\n\n        image: \"Image <img> Ctrl+G\",\n        imagedescription: \"enter image description here\",\n        imagedialog: \"<p><b>Insert Image</b></p><p>http://example.com/images/diagram.jpg \\\"optional title\\\"</p>\",\n\n        olist: \"Numbered List <ol> Ctrl+O\",\n        ulist: \"Bulleted List <ul> Ctrl+U\",\n        litem: \"List item\",\n\n        heading: \"Heading <h1>/<h2> Ctrl+H\",\n        headingexample: \"Heading\",\n\n        hr: \"Horizontal Rule <hr> Ctrl+R\",\n\n        undo: \"Undo - Ctrl+Z\",\n        redo: \"Redo - Ctrl+Y\",\n        redomac: \"Redo - Ctrl+Shift+Z\",\n\n        help: \"Markdown Editing Help\",\n\n        ok: \"OK\",\n        cancel: \"Cancel\"\n    };\n\n\n    // -------------------------------------------------------------------\n    //  YOUR CHANGES GO HERE\n    //\n    // I've tried to localize the things you are likely to change to\n    // this area.\n    // -------------------------------------------------------------------\n\n    // The default text that appears in the dialog input box when entering\n    // links.\n    var imageDefaultText = \"http://\";\n    var linkDefaultText = \"http://\";\n\n    // -------------------------------------------------------------------\n    //  END OF YOUR CHANGES\n    // -------------------------------------------------------------------\n\n    // options, if given, can have the following properties:\n    //   options.helpButton = { handler: yourEventHandler }\n    //   options.strings = { italicexample: \"slanted text\" }\n    //   options.wrapImageInLink = true\n    //   options.convertImagesToLinks = true\n    // `yourEventHandler` is the click handler for the help button.\n    // If `options.helpButton` isn't given, not help button is created.\n    // `options.strings` can have any or all of the same properties as\n    // `defaultStrings` above, so you can just override some string displayed\n    // to the user on a case-by-case basis, or translate all strings to\n    // a different language.\n    //\n    // For backwards compatibility reasons, the `options` argument can also\n    // be just the `helpButton` object, and `strings.help` can also be set via\n    // `helpButton.title`. This should be considered legacy.\n    //\n    // The constructed editor object has the methods:\n    // - getConverter() returns the markdown converter object that was passed to the constructor\n    // - run() actually starts the editor; should be called after all necessary plugins are registered. Calling this more than once is a no-op.\n    // - refreshPreview() forces the preview to be updated. This method is only available after run() was called.\n    Markdown.Editor = function (markdownConverter, idPostfix, options) {\n        \n        options = options || {};\n\n        if (typeof options.handler === \"function\") { //backwards compatible behavior\n            options = { helpButton: options };\n        }\n        options.strings = options.strings || {};\n        if (options.helpButton) {\n            options.strings.help = options.strings.help || options.helpButton.title;\n        }\n        var getString = function (identifier) { return options.strings[identifier] || defaultsStrings[identifier]; }\n        \n        idPostfix = idPostfix || \"\";\n\n        this.getPostfix = function () { return idPostfix; }\n\n        var hooks = this.hooks = new Markdown.HookCollection();\n        hooks.addNoop(\"onPreviewRefresh\");       // called with no arguments after the preview has been refreshed\n        hooks.addNoop(\"postBlockquoteCreation\"); // called with the user's selection *after* the blockquote was created; should return the actual to-be-inserted text\n        hooks.addFalse(\"insertImageDialog\");     /* called with one parameter: a callback to be called with the URL of the image. If the application creates\n                                                  * its own image insertion dialog, this hook should return true, and the callback should be called with the chosen\n                                                  * image url (or null if the user cancelled). If this hook returns false, the default dialog will be used.\n                                                  */\n        hooks.addNoop(\"imageConvertedToLink\");  // called with no arguments if an image was converted \n        hooks.addFalse(\"insertLinkDialog\");     /* called with one parameter: a callback to be called with the URL.\n                                                 * works identical to insertImageDialog (see above)\n                                                 */\n\n        this.getConverter = function () { return markdownConverter; }\n\n        var that = this,\n            panels;\n\n        this.run = function () {\n            if (panels)\n                return; // already initialized\n\n            panels = new PanelCollection(idPostfix);\n            var commandManager = new CommandManager(hooks, getString, markdownConverter, options.wrapImageInLink, options.convertImagesToLinks);\n            var previewManager = new PreviewManager(markdownConverter, panels, function () { hooks.onPreviewRefresh(); });\n            var undoManager, uiManager;\n\n            if (!/\\?noundo/.test(doc.location.href)) {\n                undoManager = new UndoManager(function () {\n                    previewManager.refresh();\n                    if (uiManager) // not available on the first call\n                        uiManager.setUndoRedoButtonStates();\n                }, panels);\n                this.textOperation = function (f) {\n                    undoManager.setCommandMode();\n                    f();\n                    that.refreshPreview();\n                }\n            }\n\n            uiManager = new UIManager(idPostfix, panels, undoManager, previewManager, commandManager, options.helpButton, getString);\n            uiManager.setUndoRedoButtonStates();\n\n            var forceRefresh = that.refreshPreview = function () { previewManager.refresh(true); };\n\n            forceRefresh();\n        };\n\n    }\n\n    // before: contains all the text in the input box BEFORE the selection.\n    // after: contains all the text in the input box AFTER the selection.\n    function Chunks() { }\n\n    // startRegex: a regular expression to find the start tag\n    // endRegex: a regular expresssion to find the end tag\n    Chunks.prototype.findTags = function (startRegex, endRegex) {\n\n        var chunkObj = this;\n        var regex;\n\n        if (startRegex) {\n\n            regex = util.extendRegExp(startRegex, \"\", \"$\");\n\n            this.before = this.before.replace(regex,\n                function (match) {\n                    chunkObj.startTag = chunkObj.startTag + match;\n                    return \"\";\n                });\n\n            regex = util.extendRegExp(startRegex, \"^\", \"\");\n\n            this.selection = this.selection.replace(regex,\n                function (match) {\n                    chunkObj.startTag = chunkObj.startTag + match;\n                    return \"\";\n                });\n        }\n\n        if (endRegex) {\n\n            regex = util.extendRegExp(endRegex, \"\", \"$\");\n\n            this.selection = this.selection.replace(regex,\n                function (match) {\n                    chunkObj.endTag = match + chunkObj.endTag;\n                    return \"\";\n                });\n\n            regex = util.extendRegExp(endRegex, \"^\", \"\");\n\n            this.after = this.after.replace(regex,\n                function (match) {\n                    chunkObj.endTag = match + chunkObj.endTag;\n                    return \"\";\n                });\n        }\n    };\n\n    // If remove is false, the whitespace is transferred\n    // to the before/after regions.\n    //\n    // If remove is true, the whitespace disappears.\n    Chunks.prototype.trimWhitespace = function (remove) {\n        var beforeReplacer, afterReplacer, that = this;\n        if (remove) {\n            beforeReplacer = afterReplacer = \"\";\n        } else {\n            beforeReplacer = function (s) { that.before += s; return \"\"; }\n            afterReplacer = function (s) { that.after = s + that.after; return \"\"; }\n        }\n\n        this.selection = this.selection.replace(/^(\\s*)/, beforeReplacer).replace(/(\\s*)$/, afterReplacer);\n    };\n\n\n    Chunks.prototype.skipLines = function (nLinesBefore, nLinesAfter, findExtraNewlines) {\n\n        if (nLinesBefore === undefined) {\n            nLinesBefore = 1;\n        }\n\n        if (nLinesAfter === undefined) {\n            nLinesAfter = 1;\n        }\n\n        nLinesBefore++;\n        nLinesAfter++;\n\n        var regexText;\n        var replacementText;\n\n        // chrome bug ... documented at: http://meta.stackexchange.com/questions/63307/blockquote-glitch-in-editor-in-chrome-6-and-7/65985#65985\n        if (navigator.userAgent.match(/Chrome/)) {\n            \"X\".match(/()./);\n        }\n\n        this.selection = this.selection.replace(/(^\\n*)/, \"\");\n\n        this.startTag = this.startTag + re.$1;\n\n        this.selection = this.selection.replace(/(\\n*$)/, \"\");\n        this.endTag = this.endTag + re.$1;\n        this.startTag = this.startTag.replace(/(^\\n*)/, \"\");\n        this.before = this.before + re.$1;\n        this.endTag = this.endTag.replace(/(\\n*$)/, \"\");\n        this.after = this.after + re.$1;\n\n        if (this.before) {\n\n            regexText = replacementText = \"\";\n\n            while (nLinesBefore--) {\n                regexText += \"\\\\n?\";\n                replacementText += \"\\n\";\n            }\n\n            if (findExtraNewlines) {\n                regexText = \"\\\\n*\";\n            }\n            this.before = this.before.replace(new re(regexText + \"$\", \"\"), replacementText);\n        }\n\n        if (this.after) {\n\n            regexText = replacementText = \"\";\n\n            while (nLinesAfter--) {\n                regexText += \"\\\\n?\";\n                replacementText += \"\\n\";\n            }\n            if (findExtraNewlines) {\n                regexText = \"\\\\n*\";\n            }\n\n            this.after = this.after.replace(new re(regexText, \"\"), replacementText);\n        }\n    };\n\n    // end of Chunks\n\n    // A collection of the important regions on the page.\n    // Cached so we don't have to keep traversing the DOM.\n    // Also holds ieCachedRange and ieCachedScrollTop, where necessary; working around\n    // this issue:\n    // Internet explorer has problems with CSS sprite buttons that use HTML\n    // lists.  When you click on the background image \"button\", IE will\n    // select the non-existent link text and discard the selection in the\n    // textarea.  The solution to this is to cache the textarea selection\n    // on the button's mousedown event and set a flag.  In the part of the\n    // code where we need to grab the selection, we check for the flag\n    // and, if it's set, use the cached area instead of querying the\n    // textarea.\n    //\n    // This ONLY affects Internet Explorer (tested on versions 6, 7\n    // and 8) and ONLY on button clicks.  Keyboard shortcuts work\n    // normally since the focus never leaves the textarea.\n    function PanelCollection(postfix) {\n        this.buttonBar = doc.getElementById(\"wmd-button-bar\" + postfix);\n        this.preview = doc.getElementById(\"wmd-preview\" + postfix);\n        this.input = doc.getElementById(\"wmd-input\" + postfix);\n    };\n\n    // Returns true if the DOM element is visible, false if it's hidden.\n    // Checks if display is anything other than none.\n    util.isVisible = function (elem) {\n\n        if (window.getComputedStyle) {\n            // Most browsers\n            return window.getComputedStyle(elem, null).getPropertyValue(\"display\") !== \"none\";\n        }\n        else if (elem.currentStyle) {\n            // IE\n            return elem.currentStyle[\"display\"] !== \"none\";\n        }\n    };\n\n\n    // Adds a listener callback to a DOM element which is fired on a specified\n    // event.\n    util.addEvent = function (elem, event, listener) {\n        if (elem.attachEvent) {\n            // IE only.  The \"on\" is mandatory.\n            elem.attachEvent(\"on\" + event, listener);\n        }\n        else {\n            // Other browsers.\n            elem.addEventListener(event, listener, false);\n        }\n    };\n\n\n    // Removes a listener callback from a DOM element which is fired on a specified\n    // event.\n    util.removeEvent = function (elem, event, listener) {\n        if (elem.detachEvent) {\n            // IE only.  The \"on\" is mandatory.\n            elem.detachEvent(\"on\" + event, listener);\n        }\n        else {\n            // Other browsers.\n            elem.removeEventListener(event, listener, false);\n        }\n    };\n\n    // Converts \\r\\n and \\r to \\n.\n    util.fixEolChars = function (text) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n        text = text.replace(/\\r/g, \"\\n\");\n        return text;\n    };\n\n    // Extends a regular expression.  Returns a new RegExp\n    // using pre + regex + post as the expression.\n    // Used in a few functions where we have a base\n    // expression and we want to pre- or append some\n    // conditions to it (e.g. adding \"$\" to the end).\n    // The flags are unchanged.\n    //\n    // regex is a RegExp, pre and post are strings.\n    util.extendRegExp = function (regex, pre, post) {\n\n        if (pre === null || pre === undefined) {\n            pre = \"\";\n        }\n        if (post === null || post === undefined) {\n            post = \"\";\n        }\n\n        var pattern = regex.toString();\n        var flags;\n\n        // Replace the flags with empty space and store them.\n        pattern = pattern.replace(/\\/([gim]*)$/, function (wholeMatch, flagsPart) {\n            flags = flagsPart;\n            return \"\";\n        });\n\n        // Remove the slash delimiters on the regular expression.\n        pattern = pattern.replace(/(^\\/|\\/$)/g, \"\");\n        pattern = pre + pattern + post;\n\n        return new re(pattern, flags);\n    }\n\n    // UNFINISHED\n    // The assignment in the while loop makes jslint cranky.\n    // I'll change it to a better loop later.\n    position.getTop = function (elem, isInner) {\n        var result = elem.offsetTop;\n        if (!isInner) {\n            while (elem = elem.offsetParent) {\n                result += elem.offsetTop;\n            }\n        }\n        return result;\n    };\n\n    position.getHeight = function (elem) {\n        return elem.offsetHeight || elem.scrollHeight;\n    };\n\n    position.getWidth = function (elem) {\n        return elem.offsetWidth || elem.scrollWidth;\n    };\n\n    position.getPageSize = function () {\n\n        var scrollWidth, scrollHeight;\n        var innerWidth, innerHeight;\n\n        // It's not very clear which blocks work with which browsers.\n        if (self.innerHeight && self.scrollMaxY) {\n            scrollWidth = doc.body.scrollWidth;\n            scrollHeight = self.innerHeight + self.scrollMaxY;\n        }\n        else if (doc.body.scrollHeight > doc.body.offsetHeight) {\n            scrollWidth = doc.body.scrollWidth;\n            scrollHeight = doc.body.scrollHeight;\n        }\n        else {\n            scrollWidth = doc.body.offsetWidth;\n            scrollHeight = doc.body.offsetHeight;\n        }\n\n        if (self.innerHeight) {\n            // Non-IE browser\n            innerWidth = self.innerWidth;\n            innerHeight = self.innerHeight;\n        }\n        else if (doc.documentElement && doc.documentElement.clientHeight) {\n            // Some versions of IE (IE 6 w/ a DOCTYPE declaration)\n            innerWidth = doc.documentElement.clientWidth;\n            innerHeight = doc.documentElement.clientHeight;\n        }\n        else if (doc.body) {\n            // Other versions of IE\n            innerWidth = doc.body.clientWidth;\n            innerHeight = doc.body.clientHeight;\n        }\n\n        var maxWidth = Math.max(scrollWidth, innerWidth);\n        var maxHeight = Math.max(scrollHeight, innerHeight);\n        return [maxWidth, maxHeight, innerWidth, innerHeight];\n    };\n\n    // Handles pushing and popping TextareaStates for undo/redo commands.\n    // I should rename the stack variables to list.\n    function UndoManager(callback, panels) {\n\n        var undoObj = this;\n        var undoStack = []; // A stack of undo states\n        var stackPtr = 0; // The index of the current state\n        var mode = \"none\";\n        var lastState; // The last state\n        var timer; // The setTimeout handle for cancelling the timer\n        var inputStateObj;\n\n        // Set the mode for later logic steps.\n        var setMode = function (newMode, noSave) {\n            if (mode != newMode) {\n                mode = newMode;\n                if (!noSave) {\n                    saveState();\n                }\n            }\n\n            if (!uaSniffed.isIE || mode != \"moving\") {\n                timer = setTimeout(refreshState, 1);\n            }\n            else {\n                inputStateObj = null;\n            }\n        };\n\n        var refreshState = function (isInitialState) {\n            inputStateObj = new TextareaState(panels, isInitialState);\n            timer = undefined;\n        };\n\n        this.setCommandMode = function () {\n            mode = \"command\";\n            saveState();\n            timer = setTimeout(refreshState, 0);\n        };\n\n        this.canUndo = function () {\n            return stackPtr > 1;\n        };\n\n        this.canRedo = function () {\n            if (undoStack[stackPtr + 1]) {\n                return true;\n            }\n            return false;\n        };\n\n        // Removes the last state and restores it.\n        this.undo = function () {\n\n            if (undoObj.canUndo()) {\n                if (lastState) {\n                    // What about setting state -1 to null or checking for undefined?\n                    lastState.restore();\n                    lastState = null;\n                }\n                else {\n                    undoStack[stackPtr] = new TextareaState(panels);\n                    undoStack[--stackPtr].restore();\n\n                    if (callback) {\n                        callback();\n                    }\n                }\n            }\n\n            mode = \"none\";\n            panels.input.focus();\n            refreshState();\n        };\n\n        // Redo an action.\n        this.redo = function () {\n\n            if (undoObj.canRedo()) {\n\n                undoStack[++stackPtr].restore();\n\n                if (callback) {\n                    callback();\n                }\n            }\n\n            mode = \"none\";\n            panels.input.focus();\n            refreshState();\n        };\n\n        // Push the input area state to the stack.\n        var saveState = function () {\n            var currState = inputStateObj || new TextareaState(panels);\n\n            if (!currState) {\n                return false;\n            }\n            if (mode == \"moving\") {\n                if (!lastState) {\n                    lastState = currState;\n                }\n                return;\n            }\n            if (lastState) {\n                if (undoStack[stackPtr - 1].text != lastState.text) {\n                    undoStack[stackPtr++] = lastState;\n                }\n                lastState = null;\n            }\n            undoStack[stackPtr++] = currState;\n            undoStack[stackPtr + 1] = null;\n            if (callback) {\n                callback();\n            }\n        };\n\n        var handleCtrlYZ = function (event) {\n\n            var handled = false;\n\n            if ((event.ctrlKey || event.metaKey) && !event.altKey) {\n\n                // IE and Opera do not support charCode.\n                var keyCode = event.charCode || event.keyCode;\n                var keyCodeChar = String.fromCharCode(keyCode);\n\n                switch (keyCodeChar.toLowerCase()) {\n\n                    case \"y\":\n                        undoObj.redo();\n                        handled = true;\n                        break;\n\n                    case \"z\":\n                        if (!event.shiftKey) {\n                            undoObj.undo();\n                        }\n                        else {\n                            undoObj.redo();\n                        }\n                        handled = true;\n                        break;\n                }\n            }\n\n            if (handled) {\n                if (event.preventDefault) {\n                    event.preventDefault();\n                }\n                if (window.event) {\n                    window.event.returnValue = false;\n                }\n                return;\n            }\n        };\n\n        // Set the mode depending on what is going on in the input area.\n        var handleModeChange = function (event) {\n\n            if (!event.ctrlKey && !event.metaKey) {\n\n                var keyCode = event.keyCode;\n\n                if ((keyCode >= 33 && keyCode <= 40) || (keyCode >= 63232 && keyCode <= 63235)) {\n                    // 33 - 40: page up/dn and arrow keys\n                    // 63232 - 63235: page up/dn and arrow keys on safari\n                    setMode(\"moving\");\n                }\n                else if (keyCode == 8 || keyCode == 46 || keyCode == 127) {\n                    // 8: backspace\n                    // 46: delete\n                    // 127: delete\n                    setMode(\"deleting\");\n                }\n                else if (keyCode == 13) {\n                    // 13: Enter\n                    setMode(\"newlines\");\n                }\n                else if (keyCode == 27) {\n                    // 27: escape\n                    setMode(\"escape\");\n                }\n                else if ((keyCode < 16 || keyCode > 20) && keyCode != 91) {\n                    // 16-20 are shift, etc.\n                    // 91: left window key\n                    // I think this might be a little messed up since there are\n                    // a lot of nonprinting keys above 20.\n                    setMode(\"typing\");\n                }\n            }\n        };\n\n        var setEventHandlers = function () {\n            util.addEvent(panels.input, \"keypress\", function (event) {\n                // keyCode 89: y\n                // keyCode 90: z\n                if ((event.ctrlKey || event.metaKey) && !event.altKey && (event.keyCode == 89 || event.keyCode == 90)) {\n                    event.preventDefault();\n                }\n            });\n\n            var handlePaste = function () {\n                if (uaSniffed.isIE || (inputStateObj && inputStateObj.text != panels.input.value)) {\n                    if (timer == undefined) {\n                        mode = \"paste\";\n                        saveState();\n                        refreshState();\n                    }\n                }\n            };\n\n            util.addEvent(panels.input, \"keydown\", handleCtrlYZ);\n            util.addEvent(panels.input, \"keydown\", handleModeChange);\n            util.addEvent(panels.input, \"mousedown\", function () {\n                setMode(\"moving\");\n            });\n\n            panels.input.onpaste = handlePaste;\n            panels.input.ondrop = handlePaste;\n        };\n\n        var init = function () {\n            setEventHandlers();\n            refreshState(true);\n            saveState();\n        };\n\n        init();\n    }\n\n    // end of UndoManager\n\n    // The input textarea state/contents.\n    // This is used to implement undo/redo by the undo manager.\n    function TextareaState(panels, isInitialState) {\n\n        // Aliases\n        var stateObj = this;\n        var inputArea = panels.input;\n        this.init = function () {\n            if (!util.isVisible(inputArea)) {\n                return;\n            }\n            if (!isInitialState && doc.activeElement && doc.activeElement !== inputArea) { // this happens when tabbing out of the input box\n                return;\n            }\n\n            this.setInputAreaSelectionStartEnd();\n            this.scrollTop = inputArea.scrollTop;\n            if (!this.text && inputArea.selectionStart || inputArea.selectionStart === 0) {\n                this.text = inputArea.value;\n            }\n\n        }\n\n        // Sets the selected text in the input box after we've performed an\n        // operation.\n        this.setInputAreaSelection = function () {\n\n            if (!util.isVisible(inputArea)) {\n                return;\n            }\n\n            if (inputArea.selectionStart !== undefined && !uaSniffed.isOpera) {\n\n                inputArea.focus();\n                inputArea.selectionStart = stateObj.start;\n                inputArea.selectionEnd = stateObj.end;\n                inputArea.scrollTop = stateObj.scrollTop;\n            }\n            else if (doc.selection) {\n\n                if (doc.activeElement && doc.activeElement !== inputArea) {\n                    return;\n                }\n\n                inputArea.focus();\n                var range = inputArea.createTextRange();\n                range.moveStart(\"character\", -inputArea.value.length);\n                range.moveEnd(\"character\", -inputArea.value.length);\n                range.moveEnd(\"character\", stateObj.end);\n                range.moveStart(\"character\", stateObj.start);\n                range.select();\n            }\n        };\n\n        this.setInputAreaSelectionStartEnd = function () {\n\n            if (!panels.ieCachedRange && (inputArea.selectionStart || inputArea.selectionStart === 0)) {\n\n                stateObj.start = inputArea.selectionStart;\n                stateObj.end = inputArea.selectionEnd;\n            }\n            else if (doc.selection) {\n\n                stateObj.text = util.fixEolChars(inputArea.value);\n\n                // IE loses the selection in the textarea when buttons are\n                // clicked.  On IE we cache the selection. Here, if something is cached,\n                // we take it.\n                var range = panels.ieCachedRange || doc.selection.createRange();\n\n                var fixedRange = util.fixEolChars(range.text);\n                var marker = \"\\x07\";\n                var markedRange = marker + fixedRange + marker;\n                range.text = markedRange;\n                var inputText = util.fixEolChars(inputArea.value);\n\n                range.moveStart(\"character\", -markedRange.length);\n                range.text = fixedRange;\n\n                stateObj.start = inputText.indexOf(marker);\n                stateObj.end = inputText.lastIndexOf(marker) - marker.length;\n\n                var len = stateObj.text.length - util.fixEolChars(inputArea.value).length;\n\n                if (len) {\n                    range.moveStart(\"character\", -fixedRange.length);\n                    while (len--) {\n                        fixedRange += \"\\n\";\n                        stateObj.end += 1;\n                    }\n                    range.text = fixedRange;\n                }\n\n                if (panels.ieCachedRange)\n                    stateObj.scrollTop = panels.ieCachedScrollTop; // this is set alongside with ieCachedRange\n\n                panels.ieCachedRange = null;\n\n                this.setInputAreaSelection();\n            }\n        };\n\n        // Restore this state into the input area.\n        this.restore = function () {\n\n            if (stateObj.text != undefined && stateObj.text != inputArea.value) {\n                inputArea.value = stateObj.text;\n            }\n            this.setInputAreaSelection();\n            inputArea.scrollTop = stateObj.scrollTop;\n        };\n\n        // Gets a collection of HTML chunks from the inptut textarea.\n        this.getChunks = function () {\n\n            var chunk = new Chunks();\n            chunk.before = util.fixEolChars(stateObj.text.substring(0, stateObj.start));\n            chunk.startTag = \"\";\n            chunk.selection = util.fixEolChars(stateObj.text.substring(stateObj.start, stateObj.end));\n            chunk.endTag = \"\";\n            chunk.after = util.fixEolChars(stateObj.text.substring(stateObj.end));\n            chunk.scrollTop = stateObj.scrollTop;\n\n            return chunk;\n        };\n\n        // Sets the TextareaState properties given a chunk of markdown.\n        this.setChunks = function (chunk) {\n\n            chunk.before = chunk.before + chunk.startTag;\n            chunk.after = chunk.endTag + chunk.after;\n\n            this.start = chunk.before.length;\n            this.end = chunk.before.length + chunk.selection.length;\n            this.text = chunk.before + chunk.selection + chunk.after;\n            this.scrollTop = chunk.scrollTop;\n        };\n        this.init();\n    };\n\n    function PreviewManager(converter, panels, previewRefreshCallback) {\n\n        var managerObj = this;\n        var timeout;\n        var elapsedTime;\n        var oldInputText;\n        var maxDelay = 3000;\n        var startType = \"delayed\"; // The other legal value is \"manual\"\n\n        // Adds event listeners to elements\n        var setupEvents = function (inputElem, listener) {\n\n            util.addEvent(inputElem, \"input\", listener);\n            inputElem.onpaste = listener;\n            inputElem.ondrop = listener;\n\n            util.addEvent(inputElem, \"keypress\", listener);\n            util.addEvent(inputElem, \"keydown\", listener);\n        };\n\n        var getDocScrollTop = function () {\n\n            var result = 0;\n\n            if (window.innerHeight) {\n                result = window.pageYOffset;\n            }\n            else\n                if (doc.documentElement && doc.documentElement.scrollTop) {\n                    result = doc.documentElement.scrollTop;\n                }\n                else\n                    if (doc.body) {\n                        result = doc.body.scrollTop;\n                    }\n\n            return result;\n        };\n\n        var makePreviewHtml = function () {\n\n            // If there is no registered preview panel\n            // there is nothing to do.\n            if (!panels.preview)\n                return;\n\n\n            var text = panels.input.value;\n            if (text && text == oldInputText) {\n                return; // Input text hasn't changed.\n            }\n            else {\n                oldInputText = text;\n            }\n\n            var prevTime = new Date().getTime();\n\n            text = converter.makeHtml(text);\n\n            // Calculate the processing time of the HTML creation.\n            // It's used as the delay time in the event listener.\n            var currTime = new Date().getTime();\n            elapsedTime = currTime - prevTime;\n\n            pushPreviewHtml(text);\n        };\n\n        // setTimeout is already used.  Used as an event listener.\n        var applyTimeout = function () {\n\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = undefined;\n            }\n\n            if (startType !== \"manual\") {\n\n                var delay = 0;\n\n                if (startType === \"delayed\") {\n                    delay = elapsedTime;\n                }\n\n                if (delay > maxDelay) {\n                    delay = maxDelay;\n                }\n                timeout = setTimeout(makePreviewHtml, delay);\n            }\n        };\n\n        var getScaleFactor = function (panel) {\n            if (panel.scrollHeight <= panel.clientHeight) {\n                return 1;\n            }\n            return panel.scrollTop / (panel.scrollHeight - panel.clientHeight);\n        };\n\n        var setPanelScrollTops = function () {\n            if (panels.preview) {\n                panels.preview.scrollTop = (panels.preview.scrollHeight - panels.preview.clientHeight) * getScaleFactor(panels.preview);\n            }\n        };\n\n        this.refresh = function (requiresRefresh) {\n\n            if (requiresRefresh) {\n                oldInputText = \"\";\n                makePreviewHtml();\n            }\n            else {\n                applyTimeout();\n            }\n        };\n\n        this.processingTime = function () {\n            return elapsedTime;\n        };\n\n        var isFirstTimeFilled = true;\n\n        // IE doesn't let you use innerHTML if the element is contained somewhere in a table\n        // (which is the case for inline editing) -- in that case, detach the element, set the\n        // value, and reattach. Yes, that *is* ridiculous.\n        var ieSafePreviewSet = function (text) {\n            var preview = panels.preview;\n            var parent = preview.parentNode;\n            var sibling = preview.nextSibling;\n            parent.removeChild(preview);\n            preview.innerHTML = text;\n            if (!sibling)\n                parent.appendChild(preview);\n            else\n                parent.insertBefore(preview, sibling);\n        }\n\n        var nonSuckyBrowserPreviewSet = function (text) {\n            panels.preview.innerHTML = text;\n        }\n\n        var previewSetter;\n\n        var previewSet = function (text) {\n            if (previewSetter)\n                return previewSetter(text);\n\n            try {\n                nonSuckyBrowserPreviewSet(text);\n                previewSetter = nonSuckyBrowserPreviewSet;\n            } catch (e) {\n                previewSetter = ieSafePreviewSet;\n                previewSetter(text);\n            }\n        };\n\n        var pushPreviewHtml = function (text) {\n\n            var emptyTop = position.getTop(panels.input) - getDocScrollTop();\n\n            if (panels.preview) {\n                previewSet(text);\n                previewRefreshCallback();\n            }\n\n            setPanelScrollTops();\n\n            if (isFirstTimeFilled) {\n                isFirstTimeFilled = false;\n                return;\n            }\n\n            var fullTop = position.getTop(panels.input) - getDocScrollTop();\n\n            if (uaSniffed.isIE) {\n                setTimeout(function () {\n                    window.scrollBy(0, fullTop - emptyTop);\n                }, 0);\n            }\n            else {\n                window.scrollBy(0, fullTop - emptyTop);\n            }\n        };\n\n        var init = function () {\n\n            setupEvents(panels.input, applyTimeout);\n            makePreviewHtml();\n\n            if (panels.preview) {\n                panels.preview.scrollTop = 0;\n            }\n        };\n\n        init();\n    };\n\n    // Creates the background behind the hyperlink text entry box.\n    // And download dialog\n    // Most of this has been moved to CSS but the div creation and\n    // browser-specific hacks remain here.\n    ui.createBackground = function () {\n\n        var background = doc.createElement(\"div\"),\n            style = background.style;\n        \n        background.className = \"wmd-prompt-background\";\n        \n        style.position = \"absolute\";\n        style.top = \"0\";\n\n        style.zIndex = \"1000\";\n\n        if (uaSniffed.isIE) {\n            style.filter = \"alpha(opacity=50)\";\n        }\n        else {\n            style.opacity = \"0.5\";\n        }\n\n        var pageSize = position.getPageSize();\n        style.height = pageSize[1] + \"px\";\n\n        if (uaSniffed.isIE) {\n            style.left = doc.documentElement.scrollLeft;\n            style.width = doc.documentElement.clientWidth;\n        }\n        else {\n            style.left = \"0\";\n            style.width = \"100%\";\n        }\n\n        doc.body.appendChild(background);\n        return background;\n    };\n\n    // This simulates a modal dialog box and asks for the URL when you\n    // click the hyperlink or image buttons.\n    //\n    // text: The html for the input box.\n    // defaultInputText: The default value that appears in the input box.\n    // ok: The text for the OK button\n    // cancel: The text for the Cancel button\n    // callback: The function which is executed when the prompt is dismissed, either via OK or Cancel.\n    //      It receives a single argument; either the entered text (if OK was chosen) or null (if Cancel\n    //      was chosen).\n    ui.prompt = function (text, defaultInputText, ok, cancel, callback) {\n\n        // These variables need to be declared at this level since they are used\n        // in multiple functions.\n        var dialog;         // The dialog box.\n        var input;         // The text box where you enter the hyperlink.\n\n\n        if (defaultInputText === undefined) {\n            defaultInputText = \"\";\n        }\n\n        // Used as a keydown event handler. Esc dismisses the prompt.\n        // Key code 27 is ESC.\n        var checkEscape = function (key) {\n            var code = (key.charCode || key.keyCode);\n            if (code === 27) {\n                if (key.stopPropagation) key.stopPropagation();\n                close(true);\n                return false;\n            }\n        };\n\n        // Dismisses the hyperlink input box.\n        // isCancel is true if we don't care about the input text.\n        // isCancel is false if we are going to keep the text.\n        var close = function (isCancel) {\n            util.removeEvent(doc.body, \"keyup\", checkEscape);\n            var text = input.value;\n\n            if (isCancel) {\n                text = null;\n            }\n            else {\n                // Fixes common pasting errors.\n                text = text.replace(/^http:\\/\\/(https?|ftp):\\/\\//, '$1://');\n                if (!/^(?:https?|ftp):\\/\\//.test(text))\n                    text = 'http://' + text;\n            }\n\n            dialog.parentNode.removeChild(dialog);\n\n            callback(text);\n            return false;\n        };\n\n\n\n        // Create the text input box form/window.\n        var createDialog = function (ok, cancel) {\n\n            // The main dialog box.\n            dialog = doc.createElement(\"div\");\n            dialog.className = \"wmd-prompt-dialog\";\n            dialog.style.padding = \"10px;\";\n            dialog.style.position = \"fixed\";\n            dialog.style.width = \"400px\";\n            dialog.style.zIndex = \"1001\";\n\n            // The dialog text.\n            var question = doc.createElement(\"div\");\n            question.innerHTML = text;\n            question.style.padding = \"5px\";\n            dialog.appendChild(question);\n\n            // The web form container for the text box and buttons.\n            var form = doc.createElement(\"form\"),\n                style = form.style;\n            form.onsubmit = function () { return close(false); };\n            style.padding = \"0\";\n            style.margin = \"0\";\n            style.cssFloat = \"left\";\n            style.width = \"100%\";\n            style.textAlign = \"center\";\n            style.position = \"relative\";\n            dialog.appendChild(form);\n\n            // The input text box\n            input = doc.createElement(\"input\");\n            input.type = \"text\";\n            input.value = defaultInputText;\n            style = input.style;\n            style.display = \"block\";\n            style.width = \"80%\";\n            style.marginLeft = style.marginRight = \"auto\";\n            form.appendChild(input);\n\n            // The ok button\n            var okButton = doc.createElement(\"input\");\n            okButton.type = \"button\";\n            okButton.onclick = function () { return close(false); };\n            okButton.value = ok;\n            style = okButton.style;\n            style.margin = \"10px\";\n            style.display = \"inline\";\n            style.width = \"7em\";\n\n\n            // The cancel button\n            var cancelButton = doc.createElement(\"input\");\n            cancelButton.type = \"button\";\n            cancelButton.onclick = function () { return close(true); };\n            cancelButton.value = cancel;\n            style = cancelButton.style;\n            style.margin = \"10px\";\n            style.display = \"inline\";\n            style.width = \"7em\";\n\n            form.appendChild(okButton);\n            form.appendChild(cancelButton);\n\n            util.addEvent(doc.body, \"keyup\", checkEscape);\n            dialog.style.top = \"50%\";\n            dialog.style.left = \"50%\";\n            dialog.style.display = \"block\";\n            if (uaSniffed.isIE_5or6) {\n                dialog.style.position = \"absolute\";\n                dialog.style.top = doc.documentElement.scrollTop + 200 + \"px\";\n                dialog.style.left = \"50%\";\n            }\n            doc.body.appendChild(dialog);\n\n            // This has to be done AFTER adding the dialog to the form if you\n            // want it to be centered.\n            dialog.style.marginTop = -(position.getHeight(dialog) / 2) + \"px\";\n            dialog.style.marginLeft = -(position.getWidth(dialog) / 2) + \"px\";\n\n        };\n        // Why is this in a zero-length timeout?\n        // Is it working around a browser bug?\n        setTimeout(function () {\n\n            createDialog(ok, cancel);\n\n            var defTextLen = defaultInputText.length;\n            if (input.selectionStart !== undefined) {\n                input.selectionStart = 0;\n                input.selectionEnd = defTextLen;\n            }\n            else if (input.createTextRange) {\n                var range = input.createTextRange();\n                range.collapse(false);\n                range.moveStart(\"character\", -defTextLen);\n                range.moveEnd(\"character\", defTextLen);\n                range.select();\n            }\n\n            input.focus();\n        }, 0);\n    };\n\n    function UIManager(postfix, panels, undoManager, previewManager, commandManager, helpOptions, getString) {\n\n        var inputBox = panels.input,\n            buttons = {}; // buttons.undo, buttons.link, etc. The actual DOM elements.\n\n        makeSpritedButtonRow();\n\n        var keyEvent = \"keydown\";\n        if (uaSniffed.isOpera) {\n            keyEvent = \"keypress\";\n        }\n\n        util.addEvent(inputBox, keyEvent, function (key) {\n\n            // Check to see if we have a button key and, if so execute the callback.\n            if ((key.ctrlKey || key.metaKey) && !key.altKey && !key.shiftKey) {\n\n                var keyCode = key.charCode || key.keyCode;\n                var keyCodeStr = String.fromCharCode(keyCode).toLowerCase();\n\n                switch (keyCodeStr) {\n                    case \"b\":\n                        doClick(buttons.bold);\n                        break;\n                    case \"i\":\n                        doClick(buttons.italic);\n                        break;\n                    case \"l\":\n                        doClick(buttons.link);\n                        break;\n                    case \"q\":\n                        doClick(buttons.quote);\n                        break;\n                    case \"k\":\n                        doClick(buttons.code);\n                        break;\n                    case \"g\":\n                        doClick(buttons.image);\n                        break;\n                    case \"o\":\n                        doClick(buttons.olist);\n                        break;\n                    case \"u\":\n                        doClick(buttons.ulist);\n                        break;\n                    case \"h\":\n                        doClick(buttons.heading);\n                        break;\n                    case \"r\":\n                        doClick(buttons.hr);\n                        break;\n                    case \"y\":\n                        doClick(buttons.redo);\n                        break;\n                    case \"z\":\n                        if (key.shiftKey) {\n                            doClick(buttons.redo);\n                        }\n                        else {\n                            doClick(buttons.undo);\n                        }\n                        break;\n                    default:\n                        return;\n                }\n\n\n                if (key.preventDefault) {\n                    key.preventDefault();\n                }\n\n                if (window.event) {\n                    window.event.returnValue = false;\n                }\n            }\n        });\n\n        // Auto-indent on shift-enter\n        util.addEvent(inputBox, \"keyup\", function (key) {\n            if (key.shiftKey && !key.ctrlKey && !key.metaKey) {\n                var keyCode = key.charCode || key.keyCode;\n                // Character 13 is Enter\n                if (keyCode === 13) {\n                    var fakeButton = {};\n                    fakeButton.textOp = bindCommand(\"doAutoindent\");\n                    doClick(fakeButton);\n                }\n            }\n        });\n\n        // special handler because IE clears the context of the textbox on ESC\n        if (uaSniffed.isIE) {\n            util.addEvent(inputBox, \"keydown\", function (key) {\n                var code = key.keyCode;\n                if (code === 27) {\n                    return false;\n                }\n            });\n        }\n\n\n        // Perform the button's action.\n        function doClick(button) {\n\n            inputBox.focus();\n\n            if (button.textOp) {\n\n                if (undoManager) {\n                    undoManager.setCommandMode();\n                }\n\n                var state = new TextareaState(panels);\n\n                if (!state) {\n                    return;\n                }\n\n                var chunks = state.getChunks();\n\n                // Some commands launch a \"modal\" prompt dialog.  Javascript\n                // can't really make a modal dialog box and the WMD code\n                // will continue to execute while the dialog is displayed.\n                // This prevents the dialog pattern I'm used to and means\n                // I can't do something like this:\n                //\n                // var link = CreateLinkDialog();\n                // makeMarkdownLink(link);\n                //\n                // Instead of this straightforward method of handling a\n                // dialog I have to pass any code which would execute\n                // after the dialog is dismissed (e.g. link creation)\n                // in a function parameter.\n                //\n                // Yes this is awkward and I think it sucks, but there's\n                // no real workaround.  Only the image and link code\n                // create dialogs and require the function pointers.\n                var fixupInputArea = function () {\n\n                    inputBox.focus();\n\n                    if (chunks) {\n                        state.setChunks(chunks);\n                    }\n\n                    state.restore();\n                    previewManager.refresh();\n                };\n\n                var noCleanup = button.textOp(chunks, fixupInputArea);\n\n                if (!noCleanup) {\n                    fixupInputArea();\n                }\n\n            }\n\n            if (button.execute) {\n                button.execute(undoManager);\n            }\n        };\n\n        function setupButton(button, isEnabled) {\n\n            var normalYShift = \"0px\";\n            var disabledYShift = \"-20px\";\n            var highlightYShift = \"-40px\";\n            var image = button.getElementsByTagName(\"span\")[0];\n            if (isEnabled) {\n                image.style.backgroundPosition = button.XShift + \" \" + normalYShift;\n                button.onmouseover = function () {\n                    image.style.backgroundPosition = this.XShift + \" \" + highlightYShift;\n                };\n\n                button.onmouseout = function () {\n                    image.style.backgroundPosition = this.XShift + \" \" + normalYShift;\n                };\n\n                // IE tries to select the background image \"button\" text (it's\n                // implemented in a list item) so we have to cache the selection\n                // on mousedown.\n                if (uaSniffed.isIE) {\n                    button.onmousedown = function () {\n                        if (doc.activeElement && doc.activeElement !== panels.input) { // we're not even in the input box, so there's no selection\n                            return;\n                        }\n                        panels.ieCachedRange = document.selection.createRange();\n                        panels.ieCachedScrollTop = panels.input.scrollTop;\n                    };\n                }\n\n                if (!button.isHelp) {\n                    button.onclick = function () {\n                        if (this.onmouseout) {\n                            this.onmouseout();\n                        }\n                        doClick(this);\n                        return false;\n                    }\n                }\n            }\n            else {\n                image.style.backgroundPosition = button.XShift + \" \" + disabledYShift;\n                button.onmouseover = button.onmouseout = button.onclick = function () { };\n            }\n        }\n\n        function bindCommand(method) {\n            if (typeof method === \"string\")\n                method = commandManager[method];\n            return function () { method.apply(commandManager, arguments); }\n        }\n\n        function makeSpritedButtonRow() {\n\n            var buttonBar = panels.buttonBar;\n\n            var normalYShift = \"0px\";\n            var disabledYShift = \"-20px\";\n            var highlightYShift = \"-40px\";\n\n            var buttonRow = document.createElement(\"ul\");\n            buttonRow.id = \"wmd-button-row\" + postfix;\n            buttonRow.className = 'wmd-button-row';\n            buttonRow = buttonBar.appendChild(buttonRow);\n            var xPosition = 0;\n            var makeButton = function (id, title, XShift, textOp) {\n                var button = document.createElement(\"li\");\n                button.className = \"wmd-button\";\n                button.style.left = xPosition + \"px\";\n                xPosition += 25;\n                var buttonImage = document.createElement(\"span\");\n                button.id = id + postfix;\n                button.appendChild(buttonImage);\n                button.title = title;\n                button.XShift = XShift;\n                if (textOp)\n                    button.textOp = textOp;\n                setupButton(button, true);\n                buttonRow.appendChild(button);\n                return button;\n            };\n            var makeSpacer = function (num) {\n                var spacer = document.createElement(\"li\");\n                spacer.className = \"wmd-spacer wmd-spacer\" + num;\n                spacer.id = \"wmd-spacer\" + num + postfix;\n                buttonRow.appendChild(spacer);\n                xPosition += 25;\n            }\n\n            buttons.bold = makeButton(\"wmd-bold-button\", getString(\"bold\"), \"0px\", bindCommand(\"doBold\"));\n            buttons.italic = makeButton(\"wmd-italic-button\", getString(\"italic\"), \"-20px\", bindCommand(\"doItalic\"));\n            makeSpacer(1);\n            buttons.link = makeButton(\"wmd-link-button\", getString(\"link\"), \"-40px\", bindCommand(function (chunk, postProcessing) {\n                return this.doLinkOrImage(chunk, postProcessing, false);\n            }));\n            buttons.quote = makeButton(\"wmd-quote-button\", getString(\"quote\"), \"-60px\", bindCommand(\"doBlockquote\"));\n            buttons.code = makeButton(\"wmd-code-button\", getString(\"code\"), \"-80px\", bindCommand(\"doCode\"));\n            buttons.image = makeButton(\"wmd-image-button\", getString(\"image\"), \"-100px\", bindCommand(function (chunk, postProcessing) {\n                return this.doLinkOrImage(chunk, postProcessing, true);\n            }));\n            makeSpacer(2);\n            buttons.olist = makeButton(\"wmd-olist-button\", getString(\"olist\"), \"-120px\", bindCommand(function (chunk, postProcessing) {\n                this.doList(chunk, postProcessing, true);\n            }));\n            buttons.ulist = makeButton(\"wmd-ulist-button\", getString(\"ulist\"), \"-140px\", bindCommand(function (chunk, postProcessing) {\n                this.doList(chunk, postProcessing, false);\n            }));\n            buttons.heading = makeButton(\"wmd-heading-button\", getString(\"heading\"), \"-160px\", bindCommand(\"doHeading\"));\n            buttons.hr = makeButton(\"wmd-hr-button\", getString(\"hr\"), \"-180px\", bindCommand(\"doHorizontalRule\"));\n            makeSpacer(3);\n            buttons.undo = makeButton(\"wmd-undo-button\", getString(\"undo\"), \"-200px\", null);\n            buttons.undo.execute = function (manager) { if (manager) manager.undo(); };\n\n            var redoTitle = /win/.test(nav.platform.toLowerCase()) ?\n                getString(\"redo\") :\n                getString(\"redomac\"); // mac and other non-Windows platforms\n\n            buttons.redo = makeButton(\"wmd-redo-button\", redoTitle, \"-220px\", null);\n            buttons.redo.execute = function (manager) { if (manager) manager.redo(); };\n\n            if (helpOptions) {\n                var helpButton = document.createElement(\"li\");\n                var helpButtonImage = document.createElement(\"span\");\n                helpButton.appendChild(helpButtonImage);\n                helpButton.className = \"wmd-button wmd-help-button\";\n                helpButton.id = \"wmd-help-button\" + postfix;\n                helpButton.XShift = \"-240px\";\n                helpButton.isHelp = true;\n                helpButton.style.right = \"0px\";\n                helpButton.title = getString(\"help\");\n                helpButton.onclick = helpOptions.handler;\n\n                setupButton(helpButton, true);\n                buttonRow.appendChild(helpButton);\n                buttons.help = helpButton;\n            }\n\n            setUndoRedoButtonStates();\n        }\n\n        function setUndoRedoButtonStates() {\n            if (undoManager) {\n                setupButton(buttons.undo, undoManager.canUndo());\n                setupButton(buttons.redo, undoManager.canRedo());\n            }\n        };\n\n        this.setUndoRedoButtonStates = setUndoRedoButtonStates;\n\n    }\n\n    function CommandManager(pluginHooks, getString, converter, wrapImageInLink, convertImagesToLinks) {\n        this.hooks = pluginHooks;\n        this.getString = getString;\n        this.converter = converter;\n        this.wrapImageInLink = wrapImageInLink;\n        this.convertImagesToLinks = convertImagesToLinks;\n    }\n\n    var commandProto = CommandManager.prototype;\n\n    // The markdown symbols - 4 spaces = code, > = blockquote, etc.\n    commandProto.prefixes = \"(?:\\\\s{4,}|\\\\s*>|\\\\s*-\\\\s+|\\\\s*\\\\d+\\\\.|=|\\\\+|-|_|\\\\*|#|\\\\s*\\\\[[^\\n]]+\\\\]:)\";\n\n    // Remove markdown symbols from the chunk selection.\n    commandProto.unwrap = function (chunk) {\n        var txt = new re(\"([^\\\\n])\\\\n(?!(\\\\n|\" + this.prefixes + \"))\", \"g\");\n        chunk.selection = chunk.selection.replace(txt, \"$1 $2\");\n    };\n\n    commandProto.wrap = function (chunk, len) {\n        this.unwrap(chunk);\n        var regex = new re(\"(.{1,\" + len + \"})( +|$\\\\n?)\", \"gm\"),\n            that = this;\n\n        chunk.selection = chunk.selection.replace(regex, function (line, marked) {\n            if (new re(\"^\" + that.prefixes, \"\").test(line)) {\n                return line;\n            }\n            return marked + \"\\n\";\n        });\n\n        chunk.selection = chunk.selection.replace(/\\s+$/, \"\");\n    };\n\n    commandProto.doBold = function (chunk, postProcessing) {\n        return this.doBorI(chunk, postProcessing, 2, this.getString(\"boldexample\"));\n    };\n\n    commandProto.doItalic = function (chunk, postProcessing) {\n        return this.doBorI(chunk, postProcessing, 1, this.getString(\"italicexample\"));\n    };\n\n    // chunk: The selected region that will be enclosed with */**\n    // nStars: 1 for italics, 2 for bold\n    // insertText: If you just click the button without highlighting text, this gets inserted\n    commandProto.doBorI = function (chunk, postProcessing, nStars, insertText) {\n\n        // Get rid of whitespace and fixup newlines.\n        chunk.trimWhitespace();\n        chunk.selection = chunk.selection.replace(/\\n{2,}/g, \"\\n\");\n\n        // Look for stars before and after.  Is the chunk already marked up?\n        // note that these regex matches cannot fail\n        var starsBefore = /(\\**$)/.exec(chunk.before)[0];\n        var starsAfter = /(^\\**)/.exec(chunk.after)[0];\n\n        var prevStars = Math.min(starsBefore.length, starsAfter.length);\n\n        // Remove stars if we have to since the button acts as a toggle.\n        if ((prevStars >= nStars) && (prevStars != 2 || nStars != 1)) {\n            chunk.before = chunk.before.replace(re(\"[*]{\" + nStars + \"}$\", \"\"), \"\");\n            chunk.after = chunk.after.replace(re(\"^[*]{\" + nStars + \"}\", \"\"), \"\");\n        }\n        else if (!chunk.selection && starsAfter) {\n            // It's not really clear why this code is necessary.  It just moves\n            // some arbitrary stuff around.\n            chunk.after = chunk.after.replace(/^([*_]*)/, \"\");\n            chunk.before = chunk.before.replace(/(\\s?)$/, \"\");\n            var whitespace = re.$1;\n            chunk.before = chunk.before + starsAfter + whitespace;\n        }\n        else {\n\n            // In most cases, if you don't have any selected text and click the button\n            // you'll get a selected, marked up region with the default text inserted.\n            if (!chunk.selection && !starsAfter) {\n                chunk.selection = insertText;\n            }\n\n            // Add the true markup.\n            var markup = nStars <= 1 ? \"*\" : \"**\"; // shouldn't the test be = ?\n            chunk.before = chunk.before + markup;\n            chunk.after = markup + chunk.after;\n        }\n\n        return;\n    };\n\n    commandProto.stripLinkDefs = function (text, defsToAdd) {\n\n        text = text.replace(/^[ ]{0,3}\\[(\\d+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|$)/gm,\n            function (totalMatch, id, link, newlines, title) {\n                defsToAdd[id] = totalMatch.replace(/\\s*$/, \"\");\n                if (newlines) {\n                    // Strip the title and return that separately.\n                    defsToAdd[id] = totalMatch.replace(/[\"(](.+?)[\")]$/, \"\");\n                    return newlines + title;\n                }\n                return \"\";\n            });\n\n        return text;\n    };\n\n    commandProto.addLinkDef = function (chunk, linkDef) {\n\n        var refNumber = 0; // The current reference number\n        var defsToAdd = {}; //\n        // Start with a clean slate by removing all previous link definitions.\n        chunk.before = this.stripLinkDefs(chunk.before, defsToAdd);\n        chunk.selection = this.stripLinkDefs(chunk.selection, defsToAdd);\n        chunk.after = this.stripLinkDefs(chunk.after, defsToAdd);\n\n        var defs = \"\";\n        var regex = /\\[(\\d+)\\]/g;\n        \n        // The above regex, used to update [foo][13] references after renumbering,\n        // is much too liberal; it can catch things that are not actually parsed\n        // as references (notably: code). It's impossible to know which matches are\n        // real references without performing a markdown conversion, so that's what\n        // we do. All matches are replaced with a unique reference number, which is\n        // given a unique link. The uniquifier in both cases is the character offset\n        // of the match inside the source string. The modified version is then sent\n        // through the Markdown renderer. Because link reference are stripped during\n        // rendering, the unique link is present in the rendered version if and only\n        // if the match at its offset was in fact rendered as a link or image.\n        var complete = chunk.before + chunk.selection + chunk.after;\n        var rendered = this.converter.makeHtml(complete);\n        var testlink = \"http://this-is-a-real-link.biz/\";\n        \n        // If our fake link appears in the rendered version *before* we have added it,\n        // this probably means you're a Meta Stack Exchange user who is deliberately\n        // trying to break this feature. You can still break this workaround if you\n        // attach a plugin to the converter that sometimes (!) inserts this link. In\n        // that case, consider yourself unsupported.\n        while (rendered.indexOf(testlink) != -1)\n            testlink += \"nicetry/\";\n        \n        var fakedefs = \"\\n\\n\";\n\n        var uniquified = complete.replace(regex, function uniquify(wholeMatch, id, offset) {\n            fakedefs += \" [\" + offset + \"]: \" + testlink + offset + \"/unicorn\\n\";\n            return \"[\" + offset + \"]\";\n        });\n        \n        rendered = this.converter.makeHtml(uniquified + fakedefs);\n        \n        var okayToModify = function(offset) {\n            return rendered.indexOf(testlink + offset + \"/unicorn\") !== -1;\n        }\n        \n        // property names are \"L_\" + link (prefixed to prevent collisions with built-in properties),\n        // values are the definition numbers\n        var addedDefsByUrl = {};\n        var addOrReuseDefNumber = function (def) {\n            var stripped = def.replace(/^[ ]{0,3}\\[(\\d+)\\]:/, \"\");\n            var key = \"L_\" + stripped;\n            if (key in addedDefsByUrl)\n                return addedDefsByUrl[key];\n            refNumber++;\n            def = \"  [\" + refNumber + \"]:\" + stripped;\n            defs += \"\\n\" + def;\n            addedDefsByUrl[key] = refNumber;\n            return refNumber;\n        };\n\n        // the regex is tested on the (up to) three chunks separately,\n        // so in order to have the correct offsets to check against okayToModify(), we\n        // have to keep track of how many characters are in the original source before\n        // the substring that we're looking at. Note that doLinkOrImage aligns the selection\n        // on potential brackets, so there should be no major breakage from the chunk\n        // separation.\n        var skippedChars = 0;\n\n        // note that\n        // a) the recursive call to getLink cannot go infinite, because by definition\n        //    of regex, inner is always a proper substring of wholeMatch, and\n        // b) more than one level of nesting is neither supported by the regex\n        //    nor making a lot of sense (the only use case for nesting is a linked image)\n        var getLink = function (wholeMatch, id, offset) {\n            if (!okayToModify(skippedChars + offset))\n                return wholeMatch;\n            if (defsToAdd[id]) {\n                var refnum = addOrReuseDefNumber(defsToAdd[id]);\n                return \"[\" + refnum + \"]\";\n            }\n            return wholeMatch;\n        };\n\n        var len = chunk.before.length;\n        chunk.before = chunk.before.replace(regex, getLink);\n        skippedChars += len;\n        \n        len = chunk.selection.length;\n        var refOut;\n        if (linkDef) {\n            refOut = addOrReuseDefNumber(linkDef);\n        }\n        else {\n            chunk.selection = chunk.selection.replace(regex, getLink);\n        }\n        skippedChars += len;        \n\n        chunk.after = chunk.after.replace(regex, getLink);\n\n        if (chunk.after) {\n            chunk.after = chunk.after.replace(/\\n*$/, \"\");\n        }\n        if (!chunk.after) {\n            chunk.selection = chunk.selection.replace(/\\n*$/, \"\");\n        }\n\n        chunk.after += \"\\n\\n\" + defs;\n\n        return refOut;\n    };\n\n    // takes the line as entered into the add link/as image dialog and makes\n    // sure the URL and the optinal title are \"nice\".\n    function properlyEncoded(linkdef) {\n        return linkdef.replace(/^\\s*(.*?)(?:\\s+\"(.+)\")?\\s*$/, function (wholematch, link, title) {\n            \n            var inQueryString = false;\n\n            // Having `[^\\w\\d-./]` in there is just a shortcut that lets us skip\n            // the most common characters in URLs. Replacing that it with `.` would not change\n            // the result, because encodeURI returns those characters unchanged, but it\n            // would mean lots of unnecessary replacement calls. Having `[` and `]` in that\n            // section as well means we do *not* enocde square brackets. These characters are\n            // a strange beast in URLs, but if anything, this causes URLs to be more readable,\n            // and we leave it to the browser to make sure that these links are handled without\n            // problems.\n            link = link.replace(/%(?:[\\da-fA-F]{2})|\\?|\\+|[^\\w\\d-./[\\]]/g, function (match) {\n                // Valid percent encoding. Could just return it as is, but we follow RFC3986\n                // Section 2.1 which says \"For consistency, URI producers and normalizers\n                // should use uppercase hexadecimal digits for all percent-encodings.\"\n                // Note that we also handle (illegal) stand-alone percent characters by\n                // replacing them with \"%25\"\n                if (match.length === 3 && match.charAt(0) == \"%\") {\n                    return match.toUpperCase();\n                }\n                switch (match) {\n                    case \"?\":\n                        inQueryString = true;\n                        return \"?\";\n                        break;\n                    \n                    // In the query string, a plus and a space are identical -- normalize.\n                    // Not strictly necessary, but identical behavior to the previous version\n                    // of this function.\n                    case \"+\":\n                        if (inQueryString)\n                            return \"%20\";\n                        break;\n                }\n                return encodeURI(match);\n            })\n            \n            if (title) {\n                title = title.trim ? title.trim() : title.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                title = title.replace(/\"/g, \"quot;\").replace(/\\(/g, \"&#40;\").replace(/\\)/g, \"&#41;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            }\n            return title ? link + ' \"' + title + '\"' : link;\n        });\n    }\n\n    commandProto.doLinkOrImage = function (chunk, postProcessing, isImage) {\n\n        chunk.trimWhitespace();\n        chunk.findTags(/\\s*!?\\[/, /\\][ ]?(?:\\n[ ]*)?(\\[.*?\\])?/);\n        var background;\n        var wrapImageInLink = this.wrapImageInLink;\n        var convertImagesToLinks = this.convertImagesToLinks;\n\n        if (chunk.endTag.length > 1 && chunk.startTag.length > 0) {\n\n            chunk.startTag = chunk.startTag.replace(/!?\\[/, \"\");\n            chunk.endTag = \"\";\n            this.addLinkDef(chunk, null);\n\n        }\n        else {\n            \n            // We're moving start and end tag back into the selection, since (as we're in the else block) we're not\n            // *removing* a link, but *adding* one, so whatever findTags() found is now back to being part of the\n            // link text. linkEnteredCallback takes care of escaping any brackets.\n            chunk.selection = chunk.startTag + chunk.selection + chunk.endTag;\n            chunk.startTag = chunk.endTag = \"\";\n\n            if (/\\n\\n/.test(chunk.selection)) {\n                this.addLinkDef(chunk, null);\n                return;\n            }\n            var that = this;\n            // The function to be executed when you enter a link and press OK or Cancel.\n            // Marks up the link and adds the ref.\n            var linkEnteredCallback = function (link) {\n\n                background.parentNode.removeChild(background);\n\n                if (link !== null) {\n                    // (                          $1\n                    //     [^\\\\]                  anything that's not a backslash\n                    //     (?:\\\\\\\\)*              an even number (this includes zero) of backslashes\n                    // )\n                    // (?=                        followed by\n                    //     [[\\]]                  an opening or closing bracket\n                    // )\n                    //\n                    // In other words, a non-escaped bracket. These have to be escaped now to make sure they\n                    // don't count as the end of the link or similar.\n                    // Note that the actual bracket has to be a lookahead, because (in case of to subsequent brackets),\n                    // the bracket in one match may be the \"not a backslash\" character in the next match, so it\n                    // should not be consumed by the first match.\n                    // The \"prepend a space and finally remove it\" steps makes sure there is a \"not a backslash\" at the\n                    // start of the string, so this also works if the selection begins with a bracket. We cannot solve\n                    // this by anchoring with ^, because in the case that the selection starts with two brackets, this\n                    // would mean a zero-width match at the start. Since zero-width matches advance the string position,\n                    // the first bracket could then not act as the \"not a backslash\" for the second.\n                    chunk.selection = (\" \" + chunk.selection).replace(/([^\\\\](?:\\\\\\\\)*)(?=[[\\]])/g, \"$1\\\\\").substr(1);\n                    \n                    var linkDef = \" [999]: \" + properlyEncoded(link);\n\n                    var num = that.addLinkDef(chunk, linkDef);\n                    if (!isImage || (wrapImageInLink && !convertImagesToLinks))\n                    {\n                        chunk.startTag = \"[\";\n                        chunk.endTag = \"][\" + num + \"]\";\n                    }\n                    if (isImage)\n                    {\n                        if (!convertImagesToLinks) {\n                            chunk.startTag += \"![\";\n                        } else {\n                            chunk.startTag += \"[\";\n                        }\n                        chunk.endTag = \"][\" + num + \"]\" + chunk.endTag;\n                    }\n\n                    if (!chunk.selection) {\n                        if (isImage) {\n                            chunk.selection = that.getString(\"imagedescription\");\n                        }\n                        else {\n                            chunk.selection = that.getString(\"linkdescription\");\n                        }\n                    }\n\n                    if (isImage && convertImagesToLinks) {\n                        that.hooks.imageConvertedToLink();\n                    }\n                }\n                postProcessing();\n            };\n\n            background = ui.createBackground();\n\n            if (isImage) {\n                if (!this.hooks.insertImageDialog(linkEnteredCallback))\n                    ui.prompt(this.getString(\"imagedialog\"), imageDefaultText, this.getString(\"ok\"), this.getString(\"cancel\"), linkEnteredCallback);\n            }\n            else {\n                if (!this.hooks.insertLinkDialog(linkEnteredCallback))\n                    ui.prompt(this.getString(\"linkdialog\"), linkDefaultText, this.getString(\"ok\"), this.getString(\"cancel\"), linkEnteredCallback);\n            }\n            return true;\n        }\n    };\n\n    // When making a list, hitting shift-enter will put your cursor on the next line\n    // at the current indent level.\n    commandProto.doAutoindent = function (chunk, postProcessing) {\n\n        var commandMgr = this,\n            fakeSelection = false;\n\n        chunk.before = chunk.before.replace(/(\\n|^)[ ]{0,3}([*+-]|\\d+[.])[ \\t]*\\n$/, \"\\n\\n\");\n        chunk.before = chunk.before.replace(/(\\n|^)[ ]{0,3}>[ \\t]*\\n$/, \"\\n\\n\");\n        chunk.before = chunk.before.replace(/(\\n|^)[ \\t]+\\n$/, \"\\n\\n\");\n        \n        // There's no selection, end the cursor wasn't at the end of the line:\n        // The user wants to split the current list item / code line / blockquote line\n        // (for the latter it doesn't really matter) in two. Temporarily select the\n        // (rest of the) line to achieve this.\n        if (!chunk.selection && !/^[ \\t]*(?:\\n|$)/.test(chunk.after)) {\n            chunk.after = chunk.after.replace(/^[^\\n]*/, function (wholeMatch) {\n                chunk.selection = wholeMatch;\n                return \"\";\n            });\n            fakeSelection = true;\n        }\n\n        if (/(\\n|^)[ ]{0,3}([*+-]|\\d+[.])[ \\t]+.*\\n$/.test(chunk.before)) {\n            if (commandMgr.doList) {\n                commandMgr.doList(chunk);\n            }\n        }\n        if (/(\\n|^)[ ]{0,3}>[ \\t]+.*\\n$/.test(chunk.before)) {\n            if (commandMgr.doBlockquote) {\n                commandMgr.doBlockquote(chunk);\n            }\n        }\n        if (/(\\n|^)(\\t|[ ]{4,}).*\\n$/.test(chunk.before)) {\n            if (commandMgr.doCode) {\n                commandMgr.doCode(chunk);\n            }\n        }\n        \n        if (fakeSelection) {\n            chunk.after = chunk.selection + chunk.after;\n            chunk.selection = \"\";\n        }\n    };\n\n    commandProto.doBlockquote = function (chunk, postProcessing) {\n\n        chunk.selection = chunk.selection.replace(/^(\\n*)([^\\r]+?)(\\n*)$/,\n            function (totalMatch, newlinesBefore, text, newlinesAfter) {\n                chunk.before += newlinesBefore;\n                chunk.after = newlinesAfter + chunk.after;\n                return text;\n            });\n\n        chunk.before = chunk.before.replace(/(>[ \\t]*)$/,\n            function (totalMatch, blankLine) {\n                chunk.selection = blankLine + chunk.selection;\n                return \"\";\n            });\n\n        chunk.selection = chunk.selection.replace(/^(\\s|>)+$/, \"\");\n        chunk.selection = chunk.selection || this.getString(\"quoteexample\");\n\n        // The original code uses a regular expression to find out how much of the\n        // text *directly before* the selection already was a blockquote:\n\n        /*\n        if (chunk.before) {\n        chunk.before = chunk.before.replace(/\\n?$/, \"\\n\");\n        }\n        chunk.before = chunk.before.replace(/(((\\n|^)(\\n[ \\t]*)*>(.+\\n)*.*)+(\\n[ \\t]*)*$)/,\n        function (totalMatch) {\n        chunk.startTag = totalMatch;\n        return \"\";\n        });\n        */\n\n        // This comes down to:\n        // Go backwards as many lines a possible, such that each line\n        //  a) starts with \">\", or\n        //  b) is almost empty, except for whitespace, or\n        //  c) is preceded by an unbroken chain of non-empty lines\n        //     leading up to a line that starts with \">\" and at least one more character\n        // and in addition\n        //  d) at least one line fulfills a)\n        //\n        // Since this is essentially a backwards-moving regex, it's susceptible to\n        // catstrophic backtracking and can cause the browser to hang;\n        // see e.g. http://meta.stackexchange.com/questions/9807.\n        //\n        // Hence we replaced this by a simple state machine that just goes through the\n        // lines and checks for a), b), and c).\n\n        var match = \"\",\n            leftOver = \"\",\n            line;\n        if (chunk.before) {\n            var lines = chunk.before.replace(/\\n$/, \"\").split(\"\\n\");\n            var inChain = false;\n            for (var i = 0; i < lines.length; i++) {\n                var good = false;\n                line = lines[i];\n                inChain = inChain && line.length > 0; // c) any non-empty line continues the chain\n                if (/^>/.test(line)) {                // a)\n                    good = true;\n                    if (!inChain && line.length > 1)  // c) any line that starts with \">\" and has at least one more character starts the chain\n                        inChain = true;\n                } else if (/^[ \\t]*$/.test(line)) {   // b)\n                    good = true;\n                } else {\n                    good = inChain;                   // c) the line is not empty and does not start with \">\", so it matches if and only if we're in the chain\n                }\n                if (good) {\n                    match += line + \"\\n\";\n                } else {\n                    leftOver += match + line;\n                    match = \"\\n\";\n                }\n            }\n            if (!/(^|\\n)>/.test(match)) {             // d)\n                leftOver += match;\n                match = \"\";\n            }\n        }\n\n        chunk.startTag = match;\n        chunk.before = leftOver;\n\n        // end of change\n\n        if (chunk.after) {\n            chunk.after = chunk.after.replace(/^\\n?/, \"\\n\");\n        }\n\n        chunk.after = chunk.after.replace(/^(((\\n|^)(\\n[ \\t]*)*>(.+\\n)*.*)+(\\n[ \\t]*)*)/,\n            function (totalMatch) {\n                chunk.endTag = totalMatch;\n                return \"\";\n            }\n        );\n\n        var replaceBlanksInTags = function (useBracket) {\n\n            var replacement = useBracket ? \"> \" : \"\";\n\n            if (chunk.startTag) {\n                chunk.startTag = chunk.startTag.replace(/\\n((>|\\s)*)\\n$/,\n                    function (totalMatch, markdown) {\n                        return \"\\n\" + markdown.replace(/^[ ]{0,3}>?[ \\t]*$/gm, replacement) + \"\\n\";\n                    });\n            }\n            if (chunk.endTag) {\n                chunk.endTag = chunk.endTag.replace(/^\\n((>|\\s)*)\\n/,\n                    function (totalMatch, markdown) {\n                        return \"\\n\" + markdown.replace(/^[ ]{0,3}>?[ \\t]*$/gm, replacement) + \"\\n\";\n                    });\n            }\n        };\n\n        if (/^(?![ ]{0,3}>)/m.test(chunk.selection)) {\n            this.wrap(chunk, SETTINGS.lineLength - 2);\n            chunk.selection = chunk.selection.replace(/^/gm, \"> \");\n            replaceBlanksInTags(true);\n            chunk.skipLines();\n        } else {\n            chunk.selection = chunk.selection.replace(/^[ ]{0,3}> ?/gm, \"\");\n            this.unwrap(chunk);\n            replaceBlanksInTags(false);\n\n            if (!/^(\\n|^)[ ]{0,3}>/.test(chunk.selection) && chunk.startTag) {\n                chunk.startTag = chunk.startTag.replace(/\\n{0,2}$/, \"\\n\\n\");\n            }\n\n            if (!/(\\n|^)[ ]{0,3}>.*$/.test(chunk.selection) && chunk.endTag) {\n                chunk.endTag = chunk.endTag.replace(/^\\n{0,2}/, \"\\n\\n\");\n            }\n        }\n\n        chunk.selection = this.hooks.postBlockquoteCreation(chunk.selection);\n\n        if (!/\\n/.test(chunk.selection)) {\n            chunk.selection = chunk.selection.replace(/^(> *)/,\n            function (wholeMatch, blanks) {\n                chunk.startTag += blanks;\n                return \"\";\n            });\n        }\n    };\n\n    commandProto.doCode = function (chunk, postProcessing) {\n\n        var hasTextBefore = /\\S[ ]*$/.test(chunk.before);\n        var hasTextAfter = /^[ ]*\\S/.test(chunk.after);\n\n        // Use 'four space' markdown if the selection is on its own\n        // line or is multiline.\n        if ((!hasTextAfter && !hasTextBefore) || /\\n/.test(chunk.selection)) {\n\n            chunk.before = chunk.before.replace(/[ ]{4}$/,\n                function (totalMatch) {\n                    chunk.selection = totalMatch + chunk.selection;\n                    return \"\";\n                });\n\n            var nLinesBack = 1;\n            var nLinesForward = 1;\n\n            if (/(\\n|^)(\\t|[ ]{4,}).*\\n$/.test(chunk.before)) {\n                nLinesBack = 0;\n            }\n            if (/^\\n(\\t|[ ]{4,})/.test(chunk.after)) {\n                nLinesForward = 0;\n            }\n\n            chunk.skipLines(nLinesBack, nLinesForward);\n\n            if (!chunk.selection) {\n                chunk.startTag = \"    \";\n                chunk.selection = this.getString(\"codeexample\");\n            }\n            else {\n                if (/^[ ]{0,3}\\S/m.test(chunk.selection)) {\n                    if (/\\n/.test(chunk.selection))\n                        chunk.selection = chunk.selection.replace(/^/gm, \"    \");\n                    else // if it's not multiline, do not select the four added spaces; this is more consistent with the doList behavior\n                        chunk.before += \"    \";\n                }\n                else {\n                    chunk.selection = chunk.selection.replace(/^(?:[ ]{4}|[ ]{0,3}\\t)/gm, \"\");\n                }\n            }\n        }\n        else {\n            // Use backticks (`) to delimit the code block.\n\n            chunk.trimWhitespace();\n            chunk.findTags(/`/, /`/);\n\n            if (!chunk.startTag && !chunk.endTag) {\n                chunk.startTag = chunk.endTag = \"`\";\n                if (!chunk.selection) {\n                    chunk.selection = this.getString(\"codeexample\");\n                }\n            }\n            else if (chunk.endTag && !chunk.startTag) {\n                chunk.before += chunk.endTag;\n                chunk.endTag = \"\";\n            }\n            else {\n                chunk.startTag = chunk.endTag = \"\";\n            }\n        }\n    };\n\n    commandProto.doList = function (chunk, postProcessing, isNumberedList) {\n\n        // These are identical except at the very beginning and end.\n        // Should probably use the regex extension function to make this clearer.\n        var previousItemsRegex = /(\\n|^)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+.*)(\\n.+|\\n{2,}([*+-].*|\\d+[.])[ \\t]+.*|\\n{2,}[ \\t]+\\S.*)*)\\n*$/;\n        var nextItemsRegex = /^\\n*(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+.*)(\\n.+|\\n{2,}([*+-].*|\\d+[.])[ \\t]+.*|\\n{2,}[ \\t]+\\S.*)*)\\n*/;\n\n        // The default bullet is a dash but others are possible.\n        // This has nothing to do with the particular HTML bullet,\n        // it's just a markdown bullet.\n        var bullet = \"-\";\n\n        // The number in a numbered list.\n        var num = 1;\n\n        // Get the item prefix - e.g. \" 1. \" for a numbered list, \" - \" for a bulleted list.\n        var getItemPrefix = function () {\n            var prefix;\n            if (isNumberedList) {\n                prefix = \" \" + num + \". \";\n                num++;\n            }\n            else {\n                prefix = \" \" + bullet + \" \";\n            }\n            return prefix;\n        };\n\n        // Fixes the prefixes of the other list items.\n        var getPrefixedItem = function (itemText) {\n\n            // The numbering flag is unset when called by autoindent.\n            if (isNumberedList === undefined) {\n                isNumberedList = /^\\s*\\d/.test(itemText);\n            }\n\n            // Renumber/bullet the list element.\n            itemText = itemText.replace(/^[ ]{0,3}([*+-]|\\d+[.])\\s/gm,\n                function (_) {\n                    return getItemPrefix();\n                });\n\n            return itemText;\n        };\n\n        chunk.findTags(/(\\n|^)*[ ]{0,3}([*+-]|\\d+[.])\\s+/, null);\n\n        if (chunk.before && !/\\n$/.test(chunk.before) && !/^\\n/.test(chunk.startTag)) {\n            chunk.before += chunk.startTag;\n            chunk.startTag = \"\";\n        }\n\n        if (chunk.startTag) {\n\n            var hasDigits = /\\d+[.]/.test(chunk.startTag);\n            chunk.startTag = \"\";\n            chunk.selection = chunk.selection.replace(/\\n[ ]{4}/g, \"\\n\");\n            this.unwrap(chunk);\n            chunk.skipLines();\n\n            if (hasDigits) {\n                // Have to renumber the bullet points if this is a numbered list.\n                chunk.after = chunk.after.replace(nextItemsRegex, getPrefixedItem);\n            }\n            if (isNumberedList == hasDigits) {\n                return;\n            }\n        }\n\n        var nLinesUp = 1;\n\n        chunk.before = chunk.before.replace(previousItemsRegex,\n            function (itemText) {\n                if (/^\\s*([*+-])/.test(itemText)) {\n                    bullet = re.$1;\n                }\n                nLinesUp = /[^\\n]\\n\\n[^\\n]/.test(itemText) ? 1 : 0;\n                return getPrefixedItem(itemText);\n            });\n\n        if (!chunk.selection) {\n            chunk.selection = this.getString(\"litem\");\n        }\n\n        var prefix = getItemPrefix();\n\n        var nLinesDown = 1;\n\n        chunk.after = chunk.after.replace(nextItemsRegex,\n            function (itemText) {\n                nLinesDown = /[^\\n]\\n\\n[^\\n]/.test(itemText) ? 1 : 0;\n                return getPrefixedItem(itemText);\n            });\n\n        chunk.trimWhitespace(true);\n        chunk.skipLines(nLinesUp, nLinesDown, true);\n        chunk.startTag = prefix;\n        var spaces = prefix.replace(/./g, \" \");\n        this.wrap(chunk, SETTINGS.lineLength - spaces.length);\n        chunk.selection = chunk.selection.replace(/\\n/g, \"\\n\" + spaces);\n\n    };\n\n    commandProto.doHeading = function (chunk, postProcessing) {\n\n        // Remove leading/trailing whitespace and reduce internal spaces to single spaces.\n        chunk.selection = chunk.selection.replace(/\\s+/g, \" \");\n        chunk.selection = chunk.selection.replace(/(^\\s+|\\s+$)/g, \"\");\n\n        // If we clicked the button with no selected text, we just\n        // make a level 2 hash header around some default text.\n        if (!chunk.selection) {\n            chunk.startTag = \"## \";\n            chunk.selection = this.getString(\"headingexample\");\n            chunk.endTag = \" ##\";\n            return;\n        }\n\n        var headerLevel = 0;     // The existing header level of the selected text.\n\n        // Remove any existing hash heading markdown and save the header level.\n        chunk.findTags(/#+[ ]*/, /[ ]*#+/);\n        if (/#+/.test(chunk.startTag)) {\n            headerLevel = re.lastMatch.length;\n        }\n        chunk.startTag = chunk.endTag = \"\";\n\n        // Try to get the current header level by looking for - and = in the line\n        // below the selection.\n        chunk.findTags(null, /\\s?(-+|=+)/);\n        if (/=+/.test(chunk.endTag)) {\n            headerLevel = 1;\n        }\n        if (/-+/.test(chunk.endTag)) {\n            headerLevel = 2;\n        }\n\n        // Skip to the next line so we can create the header markdown.\n        chunk.startTag = chunk.endTag = \"\";\n        chunk.skipLines(1, 1);\n\n        // We make a level 2 header if there is no current header.\n        // If there is a header level, we subtract one from the header level.\n        // If it's already a level 1 header, it's removed.\n        var headerLevelToCreate = headerLevel == 0 ? 2 : headerLevel - 1;\n\n        if (headerLevelToCreate > 0) {\n\n            // The button only creates level 1 and 2 underline headers.\n            // Why not have it iterate over hash header levels?  Wouldn't that be easier and cleaner?\n            var headerChar = headerLevelToCreate >= 2 ? \"-\" : \"=\";\n            var len = chunk.selection.length;\n            if (len > SETTINGS.lineLength) {\n                len = SETTINGS.lineLength;\n            }\n            chunk.endTag = \"\\n\";\n            while (len--) {\n                chunk.endTag += headerChar;\n            }\n        }\n    };\n\n    commandProto.doHorizontalRule = function (chunk, postProcessing) {\n        chunk.startTag = \"----------\\n\";\n        chunk.selection = \"\";\n        chunk.skipLines(2, 1, true);\n    }\n\n\n})();"
	_Assets7b4451bf44c19997d6e8ee9d3a75cba707236a6b = "(function () {\n    var output, Converter;\n    if (typeof exports === \"object\" && typeof require === \"function\") { // we're in a CommonJS (e.g. Node.js) module\n        output = exports;\n        Converter = require(\"./Markdown.Converter\").Converter;\n    } else {\n        output = window.Markdown;\n        Converter = output.Converter;\n    }\n        \n    output.getSanitizingConverter = function () {\n        var converter = new Converter();\n        converter.hooks.chain(\"postConversion\", sanitizeHtml);\n        converter.hooks.chain(\"postConversion\", balanceTags);\n        return converter;\n    }\n\n    function sanitizeHtml(html) {\n        return html.replace(/<[^>]*>?/gi, sanitizeTag);\n    }\n\n    // (tags that can be opened/closed) | (tags that stand alone)\n    var basic_tag_whitelist = /^(<\\/?(b|blockquote|code|del|dd|dl|dt|em|h1|h2|h3|i|kbd|li|ol(?: start=\"\\d+\")?|p|pre|s|sup|sub|strong|strike|ul)>|<(br|hr)\\s?\\/?>)$/i;\n    // <a href=\"url...\" optional title>|</a>\n    var a_white = /^(<a\\shref=\"((https?|ftp):\\/\\/|\\/)[-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)*[\\]$]+\"(\\stitle=\"[^\"<>]+\")?\\s?>|<\\/a>)$/i;\n\n    // <img src=\"url...\" optional width  optional height  optional alt  optional title\n    var img_white = /^(<img\\ssrc=\"(https?:\\/\\/|\\/)[-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)*[\\]$]+\"(\\swidth=\"\\d{1,3}\")?(\\sheight=\"\\d{1,3}\")?(\\salt=\"[^\"<>]*\")?(\\stitle=\"[^\"<>]*\")?\\s?\\/?>)$/i;\n\n    function sanitizeTag(tag) {\n        if (tag.match(basic_tag_whitelist) || tag.match(a_white) || tag.match(img_white))\n            return tag;\n        else {\n            var anyChange = false;\n            // if it looks like it *might* be valid, then try percent-encoding illegal characters in the src or href attribute\n            // and then try the whitelist again -- if that fixes it, then replace the found tag with the fixed one.\n            var encoded = tag.replace(/^(<a href=\"|<img src=\")([^\"]*)/i, function (wholematch, prefix, url) {\n                return prefix + url.replace(/[^-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)*[\\]$]/g, function (c) {\n                    anyChange = true;\n                    if (c == \"'\") // this is the only character that isn't in our whitelist and that is returned unchanged by encodeURIComponent()\n                        return \"%27\";\n                    else\n                        return encodeURIComponent(c);\n                    \n                });\n            });\n            if (anyChange && (encoded.match(a_white) || encoded.match(img_white)))\n                return encoded;\n        }\n        return \"\";\n    }\n\n    /// <summary>\n    /// attempt to balance HTML tags in the html string\n    /// by removing any unmatched opening or closing tags\n    /// IMPORTANT: we *assume* HTML has *already* been \n    /// sanitized and is safe/sane before balancing!\n    /// \n    /// adapted from CODESNIPPET: A8591DBA-D1D3-11DE-947C-BA5556D89593\n    /// </summary>\n    function balanceTags(html) {\n\n        if (html == \"\")\n            return \"\";\n\n        var re = /<\\/?\\w+[^>]*(\\s|$|>)/g;\n        // convert everything to lower case; this makes\n        // our case insensitive comparisons easier\n        var tags = html.toLowerCase().match(re);\n\n        // no HTML tags present? nothing to do; exit now\n        var tagcount = (tags || []).length;\n        if (tagcount == 0)\n            return html;\n\n        var tagname, tag;\n        var ignoredtags = \"<p><img><br><li><hr>\";\n        var match;\n        var tagpaired = [];\n        var tagremove = [];\n        var needsRemoval = false;\n\n        // loop through matched tags in forward order\n        for (var ctag = 0; ctag < tagcount; ctag++) {\n            tagname = tags[ctag].replace(/<\\/?(\\w+).*/, \"$1\");\n            // skip any already paired tags\n            // and skip tags in our ignore list; assume they're self-closed\n            if (tagpaired[ctag] || ignoredtags.search(\"<\" + tagname + \">\") > -1)\n                continue;\n\n            tag = tags[ctag];\n            match = -1;\n\n            if (!/^<\\//.test(tag)) {\n                // this is an opening tag\n                // search forwards (next tags), look for closing tags\n                for (var ntag = ctag + 1; ntag < tagcount; ntag++) {\n                    if (!tagpaired[ntag] && tags[ntag] == \"</\" + tagname + \">\") {\n                        match = ntag;\n                        break;\n                    }\n                }\n            }\n\n            if (match == -1)\n                needsRemoval = tagremove[ctag] = true; // mark for removal\n            else\n                tagpaired[match] = true; // mark paired\n        }\n\n        if (!needsRemoval)\n            return html;\n\n        // delete all orphaned tags from the string\n\n        var ctag = 0;\n        html = html.replace(re, function (match) {\n            var res = tagremove[ctag] ? \"\" : match;\n            ctag++;\n            return res;\n        });\n        return html;\n    }\n})();\n"
)
